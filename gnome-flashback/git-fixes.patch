diff --git a/Makefile.am b/Makefile.am
index 2740d7a..25c1a1f 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,31 +1,26 @@
+NULL =
+
 SUBDIRS = \
 	data \
 	gnome-flashback \
-	po
+	po \
+	$(NULL)
 
-ACLOCAL_AMFLAGS = -I m4 ${ACLOCAL_FLAGS}
+ACLOCAL_AMFLAGS = --install -I m4 ${ACLOCAL_FLAGS}
 
 MAINTAINERCLEANFILES = \
+	$(GITIGNORE_MAINTAINERCLEANFILES_TOPLEVEL) \
+	$(GITIGNORE_MAINTAINERCLEANFILES_MAKEFILE_IN) \
+	$(GITIGNORE_MAINTAINERCLEANFILES_M4_LIBTOOL) \
+	`find "m4" -type f -name "*.m4" -print` \
 	$(srcdir)/INSTALL \
-	$(srcdir)/aclocal.m4 \
-	$(srcdir)/compile \
-	$(srcdir)/config.guess \
-	$(srcdir)/config.h.in \
 	$(srcdir)/config.h.in~ \
-	$(srcdir)/config.sub \
-	$(srcdir)/depcomp \
-	$(srcdir)/install-sh \
-	$(srcdir)/ltmain.sh \
-	$(srcdir)/missing \
-	$(srcdir)/mkinstalldirs \
 	$(srcdir)/configure \
-	$(srcdir)/m4/intltool.m4 \
-	$(srcdir)/m4/libtool.m4 \
-	$(srcdir)/m4/ltoptions.m4 \
-	$(srcdir)/m4/ltsugar.m4 \
-	$(srcdir)/m4/ltversion.m4 \
-	$(srcdir)/m4/lt~obsolete.m4 \
-	`find "$(srcdir)" -type f -name Makefile.in -print`
+	$(NULL)
+
+EXTRA_DIST = \
+	$(wildcard $(top_srcdir)/modulesets/*.modules) \
+	$(NULL)
 
 GITIGNOREFILES = $(PACKAGE)-\*.tar.{gz,bz2,xz}
 
diff --git a/NEWS b/NEWS
index 44a25ac..0f30816 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,17 @@
+Version 3.17.2
+==============
+- workarounds: workaround for missing app menu button. (Alberts Muktupāvels)
+- workarounds: workaround for button-layout. (Alberts Muktupāvels)
+- display-config: allow loading from a system file. (Jasper St. Pierre)
+- display-config: add support for overscan compensation. (Tomeu Vizoso)
+- shell: don't grab keybinding if devirtualization failed. (Alberts Muktupāvels)
+- Updated translations:
+  Gábor Kelemen (hy), Yosef Or Boczko (he).
+
+Version 3.17.1
+==============
+- No changes.
+
 Version 3.16.1
 ==============
 - desktop-background: fixed background flickering. (Alberts Muktupāvels)
diff --git a/configure.ac b/configure.ac
index c92255a..c064bd8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,10 +1,12 @@
 m4_define([gnome_flashback_major_version], [3])
-m4_define([gnome_flashback_minor_version], [16])
-m4_define([gnome_flashback_micro_version], [1])
+m4_define([gnome_flashback_minor_version], [17])
+m4_define([gnome_flashback_micro_version], [2])
 
 AC_INIT([gnome-flashback], [gnome_flashback_major_version.gnome_flashback_minor_version.gnome_flashback_micro_version],
         [http://bugzilla.gnome.org/enter_bug.cgi?product=gnome-flashback])
 
+AX_IS_RELEASE([git-directory])
+
 AC_CONFIG_HEADERS(config.h)
 AC_CONFIG_MACRO_DIR([m4])
 
@@ -12,11 +14,13 @@ AM_INIT_AUTOMAKE([1.11 no-dist-gzip dist-xz tar-ustar -Wno-portability])
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 AM_MAINTAINER_MODE([enable])
 
+AX_CHECK_ENABLE_DEBUG([yes])
+
 AC_PROG_CC
-LT_INIT
 
-GNOME_COMPILE_WARNINGS([maximum])
-GNOME_MAINTAINER_MODE_DEFINES
+AX_COMPILER_FLAGS([WARN_CFLAGS], [WARN_LDFLAGS])
+
+LT_INIT
 
 AC_PATH_PROG(GLIB_COMPILE_RESOURCES, glib-compile-resources)
 
@@ -76,6 +80,12 @@ PKG_CHECK_MODULES(SOUND_APPLET, gtk+-3.0 >= $GTK_REQUIRED libcanberra-gtk3 >= $C
 AC_SUBST(SOUND_APPLET_CFLAGS)
 AC_SUBST(SOUND_APPLET_LIBS)
 
+PKG_CHECK_MODULES(WORKAROUNDS, glib-2.0 >= $GLIB_REQUIRED gtk+-3.0 >= $GTK_REQUIRED x11)
+AC_SUBST(WORKAROUNDS_CFLAGS)
+AC_SUBST(WORKAROUNDS_LIBS)
+
+PKG_CHECK_EXISTS([xrandr >= 1.5.0], AC_DEFINE([HAVE_XRANDR15], [1], [Define if you have support for XRandR 1.5 or greater]))
+
 AC_CONFIG_FILES([
 Makefile
 data/Makefile
@@ -90,6 +100,7 @@ gnome-flashback/libscreenshot/Makefile
 gnome-flashback/libshell/Makefile
 gnome-flashback/libsound-applet/Makefile
 gnome-flashback/libsound-applet/gvc/Makefile
+gnome-flashback/libworkarounds/Makefile
 po/Makefile.in
 ])
 
diff --git a/data/org.gnome.gnome-flashback.gschema.xml.in.in b/data/org.gnome.gnome-flashback.gschema.xml.in.in
index 09fb265..28b6bf6 100644
--- a/data/org.gnome.gnome-flashback.gschema.xml.in.in
+++ b/data/org.gnome.gnome-flashback.gschema.xml.in.in
@@ -45,8 +45,14 @@
 			<_summary>Sound applet</_summary>
 			<_description>If set to true, then GNOME Flashback application will be used to show a sound applet. This is the same sound applet that used to be a part of GNOME Control Center.</_description>
 		</key>
+		<key name="workarounds" type="b">
+			<default>true</default>
+			<_summary>Workarounds</_summary>
+			<_description>If set to true, then GNOME Flashback application will use workarounds to fix bugs.</_description>
+		</key>
 
 		<child name="desktop-background" schema="org.gnome.gnome-flashback.desktop-background"/>
+		<child name="workarounds" schema="org.gnome.gnome-flashback.workarounds"/>
 	</schema>
 
 	<schema id="org.gnome.gnome-flashback.desktop-background" path="/org/gnome/gnome-flashback/desktop-background/">
@@ -56,4 +62,17 @@
 			<_description>If set to true, then fade effect will be used to change the desktop background.</_description>
 		</key>
 	</schema>
+
+	<schema id="org.gnome.gnome-flashback.workarounds" path="/org/gnome/gnome-flashback/workarounds/">
+		<key name="fix-app-menu" type="b">
+			<default>true</default>
+			<_summary>Fix missing app menu button</_summary>
+			<_description>If set to true, then gnome-flashback will force Gtk/ShellShowsAppMenu to FALSE. Disable if you want to use gnome-settings-daemon overrides in xsettings plugin for 'Gtk/ShellShowsAppMenu' property.</_description>
+		</key>
+		<key name="fix-button-layout" type="s">
+			<default>'menu:minimize,maximize,close'</default>
+			<_summary>Fix wrong button layout</_summary>
+			<_description>If set to non-empty string, then gnome-flashback will force Gtk/DecorationLayout to value set by this setting. Set to empty string if you want to use gnome-settings-daemon overrides in xsettings plugin for 'Gtk/DecorationLayout' property.</_description>
+		</key>
+	</schema>
 </schemalist>
diff --git a/gnome-flashback/Makefile.am b/gnome-flashback/Makefile.am
index de87a1b..fc00afd 100644
--- a/gnome-flashback/Makefile.am
+++ b/gnome-flashback/Makefile.am
@@ -1,3 +1,5 @@
+NULL =
+
 SUBDIRS = \
 	libautomount-manager \
 	libdesktop-background \
@@ -7,15 +9,21 @@ SUBDIRS = \
 	libscreencast \
 	libscreenshot \
 	libshell \
-	libsound-applet
+	libsound-applet \
+	libworkarounds \
+	$(NULL)
 
 bin_PROGRAMS = \
-	gnome-flashback
+	gnome-flashback \
+	$(NULL)
 
-AM_CPPFLAGS = \
+gnome_flashback_CFLAGS = \
 	$(GNOME_FLASHBACK_CFLAGS) \
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
 	-I$(top_builddir)/gnome-flashback \
-	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\"
+	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\" \
+	$(NULL)
 
 gnome_flashback_SOURCES = \
 	flashback-application.c \
@@ -23,7 +31,13 @@ gnome_flashback_SOURCES = \
 	flashback-main.c \
 	flashback-session.c \
 	flashback-session.h \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
+
+gnome_flashback_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 gnome_flashback_LDADD = \
 	$(GNOME_FLASHBACK_LIBS) \
@@ -35,7 +49,9 @@ gnome_flashback_LDADD = \
 	$(top_builddir)/gnome-flashback/libscreencast/libscreencast.la \
 	$(top_builddir)/gnome-flashback/libscreenshot/libscreenshot.la \
 	$(top_builddir)/gnome-flashback/libshell/libshell.la \
-	$(top_builddir)/gnome-flashback/libsound-applet/libsound-applet.la
+	$(top_builddir)/gnome-flashback/libsound-applet/libsound-applet.la \
+	$(top_builddir)/gnome-flashback/libworkarounds/libworkarounds.la \
+	$(NULL)
 
 flashback-resources.c: flashback.gresource.xml $(shell $(GLIB_COMPILE_RESOURCES) --sourcedir=$(srcdir) --generate-dependencies $(srcdir)/flashback.gresource.xml)
 	$(AM_V_GEN)$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=$(srcdir) --generate --c-name flashback $<
@@ -45,14 +61,17 @@ flashback-resources.h: flashback.gresource.xml $(shell $(GLIB_COMPILE_RESOURCES)
 
 BUILT_SOURCES = \
 	flashback-resources.c \
-	flashback-resources.h
+	flashback-resources.h \
+	$(NULL)
 
 EXTRA_DIST = \
 	Adwaita.css \
 	flashback.gresource.xml \
-	HighContrast.css
+	HighContrast.css \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/flashback-application.c b/gnome-flashback/flashback-application.c
index 522b5eb..a6bc6ca 100644
--- a/gnome-flashback/flashback-application.c
+++ b/gnome-flashback/flashback-application.c
@@ -23,11 +23,12 @@
 #include "libdesktop-background/desktop-background.h"
 #include "libdisplay-config/flashback-display-config.h"
 #include "libend-session-dialog/flashback-end-session-dialog.h"
-#include "libidle-monitor/meta-idle-monitor-dbus.h"
+#include "libidle-monitor/flashback-idle-monitor.h"
 #include "libscreencast/flashback-screencast.h"
 #include "libscreenshot/flashback-screenshot.h"
 #include "libshell/flashback-shell.h"
 #include "libsound-applet/gvc-applet.h"
+#include "libworkarounds/flashback-workarounds.h"
 
 struct _FlashbackApplication
 {
@@ -43,11 +44,12 @@ struct _FlashbackApplication
   DesktopBackground         *background;
   FlashbackDisplayConfig    *config;
   FlashbackEndSessionDialog *dialog;
-  MetaIdleMonitorDBus       *idle_monitor;
+  FlashbackIdleMonitor      *idle_monitor;
   FlashbackScreencast       *screencast;
   FlashbackScreenshot       *screenshot;
   FlashbackShell            *shell;
   GvcApplet                 *applet;
+  FlashbackWorkarounds      *workarounds;
 };
 
 G_DEFINE_TYPE (FlashbackApplication, flashback_application, G_TYPE_OBJECT)
@@ -113,7 +115,7 @@ settings_changed (GSettings   *settings,
   application = FLASHBACK_APPLICATION (user_data);
 
 #define SETTING_CHANGED(variable_name, setting_name, function_name) \
-  if (key == NULL || g_strcmp0 (key, setting_name))                 \
+  if (key == NULL || g_strcmp0 (key, setting_name) == 0)            \
     {                                                               \
       if (g_settings_get_boolean (settings, setting_name))          \
         {                                                           \
@@ -129,12 +131,13 @@ settings_changed (GSettings   *settings,
   SETTING_CHANGED (automount, "automount-manager", gsd_automount_manager_new)
   SETTING_CHANGED (background, "desktop-background", desktop_background_new)
   SETTING_CHANGED (config, "display-config", flashback_display_config_new)
-  SETTING_CHANGED (idle_monitor, "idle-monitor", meta_idle_monitor_dbus_new)
+  SETTING_CHANGED (idle_monitor, "idle-monitor", flashback_idle_monitor_new)
   SETTING_CHANGED (dialog, "end-session-dialog", flashback_end_session_dialog_new)
   SETTING_CHANGED (screencast, "screencast", flashback_screencast_new)
   SETTING_CHANGED (screenshot, "screenshot", flashback_screenshot_new)
   SETTING_CHANGED (shell, "shell", flashback_shell_new)
   SETTING_CHANGED (applet, "sound-applet", gvc_applet_new)
+  SETTING_CHANGED (workarounds, "workarounds", flashback_workarounds_new)
 
 #undef SETTING_CHANGED
 
@@ -168,6 +171,7 @@ flashback_application_finalize (GObject *object)
   g_clear_object (&application->screenshot);
   g_clear_object (&application->shell);
   g_clear_object (&application->applet);
+  g_clear_object (&application->workarounds);
 
   G_OBJECT_CLASS (flashback_application_parent_class)->finalize (object);
 }
diff --git a/gnome-flashback/flashback-session.c b/gnome-flashback/flashback-session.c
index eb01277..7a5fd24 100644
--- a/gnome-flashback/flashback-session.c
+++ b/gnome-flashback/flashback-session.c
@@ -199,7 +199,7 @@ flashback_session_finalize (GObject *object)
 
 	if (priv->object_path != NULL) {
 		g_free (priv->object_path);
-		priv->object_path;
+		priv->object_path = NULL;
 	}
 
 	g_clear_object (&priv->client_proxy);
@@ -284,6 +284,7 @@ flashback_session_register_client (FlashbackSession *session)
 	GError *error;
 	const gchar *app_id;
 	const gchar *client_startup_id;
+	gchar *startup_id;
 	GVariant *parameters;
 	GVariant *res;
 
@@ -292,7 +293,15 @@ flashback_session_register_client (FlashbackSession *session)
 	app_id = "gnome-flashback";
 	client_startup_id = g_getenv ("DESKTOP_AUTOSTART_ID");
 
-	parameters = g_variant_new ("(ss)", app_id, client_startup_id ? client_startup_id : "");
+	if (client_startup_id != NULL) {
+		startup_id = g_strdup (client_startup_id);
+		g_unsetenv ("DESKTOP_AUTOSTART_ID");
+	} else {
+		startup_id = g_strdup ("");
+	}
+
+	parameters = g_variant_new ("(ss)", app_id, startup_id);
+	g_free (startup_id);
 
 	res = g_dbus_proxy_call_sync (priv->session_manager_proxy,
 	                              "RegisterClient",
diff --git a/gnome-flashback/libautomount-manager/Makefile.am b/gnome-flashback/libautomount-manager/Makefile.am
index d73127b..f79d28b 100644
--- a/gnome-flashback/libautomount-manager/Makefile.am
+++ b/gnome-flashback/libautomount-manager/Makefile.am
@@ -1,17 +1,30 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libautomount-manager.la
+	libautomount-manager.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libautomount_manager_la_CFLAGS = \
 	$(AUTOMOUNT_MANAGER_CFLAGS) \
-	-I$(top_builddir)/gnome-flashback/libautomount-manager
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
+	-I$(top_builddir)/gnome-flashback/libautomount-manager \
+	$(NULL)
 
 libautomount_manager_la_SOURCES = \
 	gsd-automount-manager.c \
 	gsd-automount-manager.h \
 	gsd-autorun.c \
-	gsd-autorun.h
+	gsd-autorun.h \
+	$(NULL)
+
+libautomount_manager_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libautomount_manager_la_LIBADD =	\
-	$(AUTOMOUNT_MANAGER_LIBS)
+	$(AUTOMOUNT_MANAGER_LIBS) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libautomount-manager/gsd-automount-manager.c b/gnome-flashback/libautomount-manager/gsd-automount-manager.c
index 43366fc..7252842 100644
--- a/gnome-flashback/libautomount-manager/gsd-automount-manager.c
+++ b/gnome-flashback/libautomount-manager/gsd-automount-manager.c
@@ -52,12 +52,9 @@ struct GsdAutomountManagerPrivate
         GList *volume_queue;
 };
 
-static void     gsd_automount_manager_class_init  (GsdAutomountManagerClass *klass);
-static void     gsd_automount_manager_init        (GsdAutomountManager      *gsd_automount_manager);
-
 G_DEFINE_TYPE (GsdAutomountManager, gsd_automount_manager, G_TYPE_OBJECT)
 
-GDBusProxy *
+static GDBusProxy *
 get_session_proxy (void)
 {
         static GDBusProxy *session_proxy;
@@ -514,7 +511,7 @@ setup_automounter (GsdAutomountManager *manager)
 				 manager, NULL);
 }
 
-void
+static void
 gsd_automount_manager_finalize (GObject *object)
 {
         GsdAutomountManager *manager  = GSD_AUTOMOUNT_MANAGER (object);
diff --git a/gnome-flashback/libautomount-manager/gsd-autorun.c b/gnome-flashback/libautomount-manager/gsd-autorun.c
index d5112df..f6dddfe 100644
--- a/gnome-flashback/libautomount-manager/gsd-autorun.c
+++ b/gnome-flashback/libautomount-manager/gsd-autorun.c
@@ -580,6 +580,8 @@ autorun_dialog_response (GtkDialog *dialog, gint response, AutorunDialogData *da
 				data->open_window_func (data->mount, data->user_data);
 		}
 		break;
+	default:
+		break;
 	}
 
 	autorun_dialog_destroy (data);
diff --git a/gnome-flashback/libdesktop-background/Makefile.am b/gnome-flashback/libdesktop-background/Makefile.am
index 0697cf9..8ef3da2 100644
--- a/gnome-flashback/libdesktop-background/Makefile.am
+++ b/gnome-flashback/libdesktop-background/Makefile.am
@@ -1,18 +1,31 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libdesktop-background.la
+	libdesktop-background.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libdesktop_background_la_CFLAGS = \
 	$(DESKTOP_BACKGROUND_CFLAGS) \
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
 	-I$(top_builddir)/gnome-flashback/libdesktop-background \
-	-DGNOME_DESKTOP_USE_UNSTABLE_API
+	-DGNOME_DESKTOP_USE_UNSTABLE_API \
+	$(NULL)
 
 libdesktop_background_la_SOURCES = \
 	desktop-background.c \
 	desktop-background.h \
 	desktop-window.c \
-	desktop-window.h
+	desktop-window.h \
+	$(NULL)
+
+libdesktop_background_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libdesktop_background_la_LIBADD = \
-	$(DESKTOP_BACKGROUND_LIBS)
+	$(DESKTOP_BACKGROUND_LIBS) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libdesktop-background/desktop-background.c b/gnome-flashback/libdesktop-background/desktop-background.c
index 3ec256f..043ea1e 100644
--- a/gnome-flashback/libdesktop-background/desktop-background.c
+++ b/gnome-flashback/libdesktop-background/desktop-background.c
@@ -108,7 +108,7 @@ get_nautilus_window (DesktopBackground *background)
 	unsigned long  items;
 	unsigned long  left;
 	unsigned char *list;
-	int            i;
+	unsigned long  i;
 	Window        *windows;
 	Window         nautilus;
 	Window         desktop;
diff --git a/gnome-flashback/libdisplay-config/Makefile.am b/gnome-flashback/libdisplay-config/Makefile.am
index ccac44f..be04193 100644
--- a/gnome-flashback/libdisplay-config/Makefile.am
+++ b/gnome-flashback/libdisplay-config/Makefile.am
@@ -1,10 +1,16 @@
+NULL =
+
 noinst_LTLIBRARIES = \
 	libdisplay-config.la
+	$(NULL)
 
-AM_CPPFLAGS = \
+libdisplay_config_la_CFLAGS = \
 	$(DISPLAY_CONFIG_CFLAGS) \
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
 	-I$(top_builddir)/gnome-flashback/libdisplay-config \
-	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\"
+	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\" \
+	$(NULL)
 
 libdisplay_config_la_SOURCES = \
 	edid-parse.c \
@@ -19,10 +25,17 @@ libdisplay_config_la_SOURCES = \
 	flashback-monitor-config.c \
 	flashback-monitor-config.h \
 	flashback-monitor-manager.c \
-	flashback-monitor-manager.h
+	flashback-monitor-manager.h \
+	$(NULL)
+
+libdisplay_config_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libdisplay_config_la_LIBADD = \
-	$(DISPLAY_CONFIG_LIBS)
+	$(DISPLAY_CONFIG_LIBS) \
+	$(NULL)
 
 meta-dbus-display-config.h:
 meta-dbus-display-config.c: org.gnome.Mutter.DisplayConfig.xml
@@ -34,13 +47,16 @@ meta-dbus-display-config.c: org.gnome.Mutter.DisplayConfig.xml
 
 BUILT_SOURCES = \
 	meta-dbus-display-config.h \
-	meta-dbus-display-config.c
+	meta-dbus-display-config.c \
+	$(NULL)
 
 EXTRA_DIST = \
 	org.gnome.Mutter.DisplayConfig.xml \
-	flashback-confirm-dialog.ui
+	flashback-confirm-dialog.ui \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libdisplay-config/edid-parse.c b/gnome-flashback/libdisplay-config/edid-parse.c
index 52bc51e..4033bc0 100644
--- a/gnome-flashback/libdisplay-config/edid-parse.c
+++ b/gnome-flashback/libdisplay-config/edid-parse.c
@@ -338,6 +338,7 @@ decode_standard_timings (const uchar *edid, MonitorInfo *info)
 	    case 0x01: h = (w / 4) * 3; break;
 	    case 0x02: h = (w / 5) * 4; break;
 	    case 0x03: h = (w / 16) * 9; break;
+	    default: break;
 	    }
 
           info->standard[i].width = w;
@@ -407,6 +408,8 @@ decode_display_descriptor (const uchar *desc,
       break;
     case 0x10:
       break;
+    default:
+      break;
     }
 }
 
diff --git a/gnome-flashback/libdisplay-config/flashback-confirm-dialog.c b/gnome-flashback/libdisplay-config/flashback-confirm-dialog.c
index 54b9c99..a366449 100644
--- a/gnome-flashback/libdisplay-config/flashback-confirm-dialog.c
+++ b/gnome-flashback/libdisplay-config/flashback-confirm-dialog.c
@@ -48,15 +48,14 @@ static void
 update_text (FlashbackConfirmDialog *dialog)
 {
   FlashbackConfirmDialogPrivate *priv;
-  const gchar *text;
   gchar *description;
 
   priv = flashback_confirm_dialog_get_instance_private (dialog);
-  text = ngettext ("Settings changes will revert in %d second",
-                   "Settings changes will revert in %d seconds",
-                   priv->timeout);
 
-  description = g_strdup_printf (text, priv->timeout);
+  description = g_strdup_printf (ngettext ("Settings changes will revert in %d second",
+                                           "Settings changes will revert in %d seconds",
+                                           priv->timeout), priv->timeout);
+
   gtk_label_set_text (GTK_LABEL (priv->description), description);
   g_free (description);
 }
@@ -165,6 +164,7 @@ flashback_confirm_dialog_class_init (FlashbackConfirmDialogClass *dialog_class)
   GtkWidgetClass *widget_class;
   GtkBindingSet *binding_set;
 
+  object_class = G_OBJECT_CLASS (dialog_class);
   widget_class = GTK_WIDGET_CLASS (dialog_class);
 
   dialog_class->close = flashback_confirm_dialog_close;
diff --git a/gnome-flashback/libdisplay-config/flashback-display-config.c b/gnome-flashback/libdisplay-config/flashback-display-config.c
index 5161ea7..ab0a20c 100644
--- a/gnome-flashback/libdisplay-config/flashback-display-config.c
+++ b/gnome-flashback/libdisplay-config/flashback-display-config.c
@@ -184,19 +184,15 @@ static char *
 make_display_name (FlashbackMonitorManager *manager,
                    MetaOutput              *output)
 {
+  MetaConnectorType type;
   char *inches = NULL;
   char *vendor_name = NULL;
   char *ret;
 
-  switch (output->connector_type)
-    {
-    case META_CONNECTOR_TYPE_LVDS:
-    case META_CONNECTOR_TYPE_eDP:
-      ret = g_strdup (_("Built-in display"));
-      goto out;
-    default:
-      break;
-    }
+  type = output->connector_type;
+
+  if (type == META_CONNECTOR_TYPE_eDP || type == META_CONNECTOR_TYPE_LVDS)
+    return g_strdup (_("Built-in display"));
 
   if (output->width_mm > 0 && output->height_mm > 0)
     {
@@ -236,7 +232,6 @@ make_display_name (FlashbackMonitorManager *manager,
       ret = g_strdup (vendor_name);
     }
 
- out:
   g_free (inches);
   g_free (vendor_name);
 
@@ -382,6 +377,10 @@ handle_get_resources (MetaDBusDisplayConfig *skeleton,
                              g_variant_new_boolean (output->is_presentation));
       g_variant_builder_add (&properties, "{sv}", "connector-type",
                              g_variant_new_string (get_connector_type_name (output->connector_type)));
+      g_variant_builder_add (&properties, "{sv}", "underscanning",
+                             g_variant_new_boolean (output->is_underscanning));
+      g_variant_builder_add (&properties, "{sv}", "supports-underscanning",
+                             g_variant_new_boolean (output->supports_underscanning));
 
       edid = flashback_monitor_manager_read_edid (manager, output);
 
@@ -393,6 +392,20 @@ handle_get_resources (MetaDBusDisplayConfig *skeleton,
           g_bytes_unref (edid);
         }
 
+      if (output->tile_info.group_id)
+        {
+          g_variant_builder_add (&properties, "{sv}", "tile",
+                                 g_variant_new ("(uuuuuuuu)",
+                                                output->tile_info.group_id,
+                                                output->tile_info.flags,
+                                                output->tile_info.max_h_tiles,
+                                                output->tile_info.max_v_tiles,
+                                                output->tile_info.loc_h_tile,
+                                                output->tile_info.loc_v_tile,
+                                                output->tile_info.tile_w,
+                                                output->tile_info.tile_h));
+        }
+
       g_variant_builder_add (&output_builder, "(uxiausauaua{sv})",
                              i, /* ID */
                              (gint64) output->winsys_id,
@@ -451,7 +464,7 @@ handle_apply_configuration (MetaDBusDisplayConfig *skeleton,
   int y;
   int new_screen_width;
   int new_screen_height;
-  guint transform;
+  gint transform;
   guint output_index;
   GPtrArray *crtc_infos;
   GPtrArray *output_infos;
@@ -623,6 +636,7 @@ handle_apply_configuration (MetaDBusDisplayConfig *skeleton,
       MetaOutputInfo *output_info;
       gboolean primary;
       gboolean presentation;
+      gboolean underscanning;
 
       if (output_index >= manager->n_outputs)
         {
@@ -641,6 +655,9 @@ handle_apply_configuration (MetaDBusDisplayConfig *skeleton,
       if (g_variant_lookup (properties, "presentation", "b", &presentation))
         output_info->is_presentation = presentation;
 
+      if (g_variant_lookup (properties, "underscanning", "b", &underscanning))
+        output_info->is_underscanning = underscanning;
+
       g_ptr_array_add (output_infos, output_info);
     }
 
@@ -968,8 +985,6 @@ flashback_display_config_class_init (FlashbackDisplayConfigClass *config_class)
 static void
 flashback_display_config_init (FlashbackDisplayConfig *config)
 {
-  MetaDBusDisplayConfig *display_config;
-
   config->skeleton = meta_dbus_display_config_skeleton_new ();
   config->manager = flashback_monitor_manager_new (config->skeleton);
   config->bus_name = g_bus_own_name (G_BUS_TYPE_SESSION,
diff --git a/gnome-flashback/libdisplay-config/flashback-monitor-config.c b/gnome-flashback/libdisplay-config/flashback-monitor-config.c
index 15ee979..e1cc171 100644
--- a/gnome-flashback/libdisplay-config/flashback-monitor-config.c
+++ b/gnome-flashback/libdisplay-config/flashback-monitor-config.c
@@ -57,6 +57,7 @@ typedef struct {
 
   gboolean is_primary;
   gboolean is_presentation;
+  gboolean is_underscanning;
 } MetaOutputConfig;
 
 typedef struct {
@@ -112,7 +113,8 @@ struct _FlashbackMonitorConfig
   gboolean                 current_is_for_laptop_lid;
   MetaConfiguration       *previous;
 
-  GFile                   *file;
+  GFile                   *user_file;
+  GFile                   *system_file;
   GCancellable            *save_cancellable;
 
   UpClient                *up_client;
@@ -234,15 +236,14 @@ key_is_laptop (MetaOutputKey *key)
 static gboolean
 output_is_laptop (MetaOutput *output)
 {
-  /* FIXME: extend with better heuristics */
-  switch (output->connector_type)
-    {
-    case META_CONNECTOR_TYPE_eDP:
-    case META_CONNECTOR_TYPE_LVDS:
-      return TRUE;
-    default:
-      return FALSE;
-    }
+  MetaConnectorType type;
+
+  type = output->connector_type;
+
+  if (type == META_CONNECTOR_TYPE_eDP || type == META_CONNECTOR_TYPE_LVDS)
+    return TRUE;
+
+  return FALSE;
 }
 
 static gboolean
@@ -487,7 +488,7 @@ crtc_assignment_assign (CrtcAssignment       *assign,
     }
   else
     {
-      MetaCRTCInfo *info = g_slice_new0 (MetaCRTCInfo);
+      info = g_slice_new0 (MetaCRTCInfo);
 
       info->crtc = crtc;
       info->mode = mode;
@@ -663,6 +664,7 @@ meta_monitor_config_assign_crtcs (MetaConfiguration       *config,
                                                 &config->keys[i]);
       output_info->is_primary = output_config->is_primary;
       output_info->is_presentation = output_config->is_presentation;
+      output_info->is_underscanning = output_config->is_underscanning;
 
       g_ptr_array_add (outputs, output_info);
     }
@@ -864,7 +866,8 @@ handle_start_element (GMarkupParseContext  *context,
              strcmp (element_name, "reflect_x") == 0 ||
              strcmp (element_name, "reflect_y") == 0 ||
              strcmp (element_name, "primary") == 0 ||
-             strcmp (element_name, "presentation") == 0) && parser->unknown_count == 0)
+             strcmp (element_name, "presentation") == 0 ||
+             strcmp (element_name, "underscanning") == 0) && parser->unknown_count == 0)
           {
             parser->state = STATE_OUTPUT_FIELD;
 
@@ -1171,6 +1174,8 @@ handle_text (GMarkupParseContext *context,
           parser->output.is_primary = read_bool (text, text_len, error);
         else if (strcmp (parser->output_field, "presentation") == 0)
           parser->output.is_presentation = read_bool (text, text_len, error);
+        else if (strcmp (parser->output_field, "underscanning") == 0)
+          parser->output.is_underscanning = read_bool (text, text_len, error);
         else
           g_assert_not_reached ();
         return;
@@ -1188,8 +1193,9 @@ static const GMarkupParser config_parser = {
   .text = handle_text,
 };
 
-static void
-flashback_monitor_config_load (FlashbackMonitorConfig *self)
+static gboolean
+load_config_file (FlashbackMonitorConfig *self,
+                  GFile                  *file)
 {
   char *contents;
   gsize size;
@@ -1207,14 +1213,11 @@ flashback_monitor_config_load (FlashbackMonitorConfig *self)
   */
 
   error = NULL;
-  ok = g_file_load_contents (self->file, NULL, &contents, &size, NULL, &error);
+  ok = g_file_load_contents (file, NULL, &contents, &size, NULL, &error);
   if (!ok)
     {
-      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
-        g_warning ("Failed to load stored monitor configuration: %s\n", error->message);
-
       g_error_free (error);
-      return;
+      return FALSE;
     }
 
   memset (&parser, 0, sizeof (ConfigParser));
@@ -1243,6 +1246,17 @@ flashback_monitor_config_load (FlashbackMonitorConfig *self)
 
   g_markup_parse_context_free (context);
   g_free (contents);
+
+  return ok;
+}
+
+static void
+flashback_monitor_config_load (FlashbackMonitorConfig *self)
+{
+  if (self->user_file && load_config_file (self, self->user_file))
+    return;
+  if (self->system_file && load_config_file (self, self->system_file))
+    return;
 }
 
 static unsigned long
@@ -1352,12 +1366,12 @@ meta_monitor_config_get_stored (FlashbackMonitorConfig *self,
  * which are internal monitors), or failing that, the one with the
  * best resolution
  */
-static MetaOutput *
+static int
 find_primary_output (MetaOutput *outputs,
                      unsigned    n_outputs)
 {
   unsigned i;
-  MetaOutput *best;
+  int best;
   int best_width, best_height;
 
   g_assert (n_outputs >= 1);
@@ -1365,23 +1379,23 @@ find_primary_output (MetaOutput *outputs,
   for (i = 0; i < n_outputs; i++)
     {
       if (outputs[i].is_primary)
-        return &outputs[i];
+        return i;
     }
 
   for (i = 0; i < n_outputs; i++)
     {
       if (output_is_laptop (&outputs[i]))
-        return &outputs[i];
+        return i;
     }
 
-  best = NULL;
+  best = -1;
   best_width = 0; best_height = 0;
   for (i = 0; i < n_outputs; i++)
     {
       if (outputs[i].preferred_mode->width * outputs[i].preferred_mode->height >
           best_width * best_height)
         {
-          best = &outputs[i];
+          best = i;
           best_width = outputs[i].preferred_mode->width;
           best_height = outputs[i].preferred_mode->height;
         }
@@ -1391,6 +1405,85 @@ find_primary_output (MetaOutput *outputs,
 }
 
 static void
+config_one_untiled_output (MetaOutput        *outputs,
+                           MetaConfiguration *config,
+                           int                idx,
+                           gboolean           is_primary,
+                           int               *x,
+                           unsigned long     *output_configured_bitmap)
+{
+  MetaOutput *output = &outputs[idx];
+
+  if (*output_configured_bitmap & (1 << idx))
+    return;
+
+  init_config_from_preferred_mode (&config->outputs[idx], output);
+  config->outputs[idx].is_primary = is_primary;
+  config->outputs[idx].rect.x = *x;
+  *x += config->outputs[idx].rect.width;
+  *output_configured_bitmap |= (1 << idx);
+}
+
+static void
+config_one_tiled_group (MetaOutput        *outputs,
+                        MetaConfiguration *config,
+                        int                base_idx,
+                        gboolean           is_primary,
+                        int                n_outputs,
+                        int               *x,
+                        unsigned long     *output_configured_bitmap)
+{
+  guint32 num_h_tile, num_v_tile, ht, vt;
+  int j;
+  int cur_x, cur_y, addx = 0;
+
+  if (*output_configured_bitmap & (1 << base_idx))
+      return;
+
+  if (outputs[base_idx].tile_info.group_id == 0)
+    return;
+
+  cur_x = cur_y = 0;
+  num_h_tile = outputs[base_idx].tile_info.max_h_tiles;
+  num_v_tile = outputs[base_idx].tile_info.max_v_tiles;
+
+  /* iterate over horizontal tiles */
+  cur_x = *x;
+  for (ht = 0; ht < num_h_tile; ht++)
+    {
+      cur_y = 0;
+      addx = 0;
+      for (vt = 0; vt < num_v_tile; vt++)
+        {
+          for (j = 0; j < n_outputs; j++)
+            {
+              if (outputs[j].tile_info.group_id != outputs[base_idx].tile_info.group_id)
+                continue;
+
+              if (outputs[j].tile_info.loc_h_tile != ht ||
+                  outputs[j].tile_info.loc_v_tile != vt)
+                continue;
+
+              if (ht == 0 && vt == 0 && is_primary)
+                config->outputs[j].is_primary = TRUE;
+
+              init_config_from_preferred_mode (&config->outputs[j], &outputs[j]);
+              config->outputs[j].rect.x = cur_x;
+              config->outputs[j].rect.y = cur_y;
+
+              *output_configured_bitmap |= (1 << j);
+              cur_y += outputs[j].tile_info.tile_h;
+              if (vt == 0)
+                addx += outputs[j].tile_info.tile_w;
+            }
+        }
+      cur_x += addx;
+    }
+
+  *x = cur_x;
+}
+
+static void
 make_linear_config (FlashbackMonitorConfig *self,
                     MetaOutput             *outputs,
                     unsigned                n_outputs,
@@ -1398,31 +1491,41 @@ make_linear_config (FlashbackMonitorConfig *self,
                     int                     max_height,
                     MetaConfiguration      *config)
 {
-  MetaOutput *primary;
+  unsigned long output_configured_bitmap = 0;
   unsigned i;
   int x;
+  int primary;
 
   g_return_if_fail (config != NULL);
 
   primary = find_primary_output (outputs, n_outputs);
 
-  x = primary->preferred_mode->width;
-  for (i = 0; i < n_outputs; i++)
+  x = 0;
+
+  /* set the primary up first at 0 */
+  if (outputs[primary].tile_info.group_id)
+    {
+      config_one_tiled_group (outputs, config, primary, TRUE, n_outputs,
+                              &x, &output_configured_bitmap);
+    }
+  else
     {
-      gboolean is_primary = (&outputs[i] == primary);
+      config_one_untiled_output (outputs, config, primary, TRUE,
+                                 &x, &output_configured_bitmap);
+    }
 
-      init_config_from_preferred_mode (&config->outputs[i], &outputs[i]);
-      config->outputs[i].is_primary = is_primary;
+  /* then add other tiled monitors */
+  for (i = 0; i < n_outputs; i++)
+    {
+      config_one_tiled_group (outputs, config, i, FALSE, n_outputs,
+                              &x, &output_configured_bitmap);
+    }
 
-      if (is_primary)
-        {
-          config->outputs[i].rect.x = 0;
-        }
-      else
-        {
-          config->outputs[i].rect.x = x;
-          x += config->outputs[i].rect.width;
-        }
+  /* then add remaining monitors */
+  for (i = 0; i < n_outputs; i++)
+    {
+      config_one_untiled_output (outputs, config, i, FALSE,
+                                 &x, &output_configured_bitmap);
     }
 }
 
@@ -1440,7 +1543,7 @@ make_suggested_config (FlashbackMonitorConfig *self,
                        MetaConfiguration      *config)
 {
   unsigned int i;
-  MetaOutput *primary;
+  int primary;
   GList *region = NULL;
 
   g_return_val_if_fail (config != NULL, FALSE);
@@ -1448,7 +1551,7 @@ make_suggested_config (FlashbackMonitorConfig *self,
 
   for (i = 0; i < n_outputs; i++)
     {
-      gboolean is_primary = (&outputs[i] == primary);
+      gboolean is_primary = ((int)i == primary);
 
       if (outputs[i].suggested_x < 0 || outputs[i].suggested_y < 0)
           return FALSE;
@@ -1594,7 +1697,7 @@ ensure_at_least_one_output (FlashbackMonitorConfig *self,
                             unsigned                n_outputs)
 {
   MetaConfiguration *config;
-  MetaOutput *primary;
+  int primary;
   unsigned i;
 
   /* Check that we have at least one active output */
@@ -1612,7 +1715,7 @@ ensure_at_least_one_output (FlashbackMonitorConfig *self,
 
   for (i = 0; i < n_outputs; i++)
     {
-      gboolean is_primary = (&outputs[i] == primary);
+      gboolean is_primary = ((int)i == primary);
 
       if (is_primary)
         {
@@ -1644,6 +1747,7 @@ init_config_from_output (MetaOutputConfig *config,
   config->transform = output->crtc->transform;
   config->is_primary = output->is_primary;
   config->is_presentation = output->is_presentation;
+  config->is_underscanning = output->is_underscanning;
 }
 
 static void
@@ -1738,7 +1842,8 @@ meta_monitor_config_save (FlashbackMonitorConfig *self)
                                       "      <reflect_x>%s</reflect_x>\n"
                                       "      <reflect_y>no</reflect_y>\n"
                                       "      <primary>%s</primary>\n"
-                                      "      <presentation>%s</presentation>\n",
+                                      "      <presentation>%s</presentation>\n"
+                                      "      <underscanning>%s</underscanning>\n",
                                       output->rect.width,
                                       output->rect.height,
                                       refresh_rate,
@@ -1747,7 +1852,8 @@ meta_monitor_config_save (FlashbackMonitorConfig *self)
                                       rotation_map[output->transform & 0x3],
                                       output->transform >= META_MONITOR_TRANSFORM_FLIPPED ? "yes" : "no",
                                       output->is_primary ? "yes" : "no",
-                                      output->is_presentation ? "yes" : "no");
+                                      output->is_presentation ? "yes" : "no",
+                                      output->is_underscanning ? "yes" : "no");
             }
 
           g_string_append (buffer, "    </output>\n");
@@ -1762,7 +1868,7 @@ meta_monitor_config_save (FlashbackMonitorConfig *self)
   closure->config = g_object_ref (self);
   closure->buffer = buffer;
 
-  g_file_replace_contents_async (self->file,
+  g_file_replace_contents_async (self->user_file,
                                  buffer->str, buffer->len,
                                  NULL, /* etag */
                                  TRUE,
@@ -1798,6 +1904,7 @@ flashback_monitor_config_init (FlashbackMonitorConfig *config)
 {
   const char *filename;
   char *path;
+  const char * const *system_dirs;
 
   config->configs = g_hash_table_new_full (config_hash, config_equal,
                                            NULL, (GDestroyNotify) config_unref);
@@ -1807,9 +1914,17 @@ flashback_monitor_config_init (FlashbackMonitorConfig *config)
     filename = "monitors.xml";
 
   path = g_build_filename (g_get_user_config_dir (), filename, NULL);
-  config->file = g_file_new_for_path (path);
+  config->user_file = g_file_new_for_path (path);
   g_free (path);
 
+  for (system_dirs = g_get_system_config_dirs (); !config->system_file && *system_dirs; system_dirs++)
+    {
+      path = g_build_filename (*system_dirs, filename, NULL);
+      if (g_file_test (path, G_FILE_TEST_EXISTS))
+        config->system_file = g_file_new_for_path (path);
+      g_free (path);
+    }
+
   config->up_client = up_client_new ();
   config->lid_is_closed = up_client_get_lid_is_closed (config->up_client);
 
diff --git a/gnome-flashback/libdisplay-config/flashback-monitor-manager.c b/gnome-flashback/libdisplay-config/flashback-monitor-manager.c
index e662ab0..f72044a 100644
--- a/gnome-flashback/libdisplay-config/flashback-monitor-manager.c
+++ b/gnome-flashback/libdisplay-config/flashback-monitor-manager.c
@@ -56,6 +56,8 @@ struct _FlashbackMonitorManagerPrivate
   int                    rr_event_base;
   int                    rr_error_base;
 
+  gboolean               has_randr15;
+
   MetaDBusDisplayConfig *display_config;
 };
 
@@ -70,6 +72,96 @@ enum
 
 static GParamSpec *object_properties[N_PROPERTIES] = { NULL, };
 
+static void
+add_monitor (FlashbackMonitorManager *manager,
+             MetaMonitorInfo         *monitor)
+{
+#ifdef HAVE_XRANDR15
+  XRRMonitorInfo *m;
+  int o;
+  Atom name;
+  char name_buf[40];
+
+  if (manager->priv->has_randr15 == FALSE)
+    return;
+
+  if (monitor->n_outputs <= 1)
+    return;
+
+  if (monitor->outputs[0]->product)
+    snprintf (name_buf, 40, "%s-%d", monitor->outputs[0]->product, monitor->outputs[0]->tile_info.group_id);
+  else
+    snprintf (name_buf, 40, "Tiled-%d", monitor->outputs[0]->tile_info.group_id);
+
+  name = XInternAtom (manager->priv->xdisplay, name_buf, False);
+  monitor->monitor_winsys_xid = name;
+  m = XRRAllocateMonitor (manager->priv->xdisplay, monitor->n_outputs);
+  if (!m)
+    return;
+
+  m->name = name;
+  m->primary = monitor->is_primary;
+  m->automatic = True;
+
+  for (o = 0; o < monitor->n_outputs; o++)
+    {
+      MetaOutput *output = monitor->outputs[o];
+      m->outputs[o] = output->winsys_id;
+    }
+
+  XRRSetMonitor (manager->priv->xdisplay,
+                 DefaultRootWindow (manager->priv->xdisplay),
+                 m);
+
+  XRRFreeMonitors (m);
+#endif
+}
+
+static void
+remove_monitor (FlashbackMonitorManager *manager,
+                int                      monitor_winsys_xid)
+{
+#ifdef HAVE_XRANDR15
+  if (manager->priv->has_randr15 == FALSE)
+    return;
+
+  XRRDeleteMonitor (manager->priv->xdisplay,
+                    DefaultRootWindow (manager->priv->xdisplay),
+                    monitor_winsys_xid);
+#endif
+}
+
+static void
+init_monitors (FlashbackMonitorManager *manager)
+{
+#ifdef HAVE_XRANDR15
+  XRRMonitorInfo *m;
+  int n, i;
+
+  if (manager->priv->has_randr15 == FALSE)
+    return;
+
+  /* delete any tiled monitors setup, as mutter will want to recreate
+     things in its image */
+  m = XRRGetMonitors (manager->priv->xdisplay,
+                      DefaultRootWindow (manager->priv->xdisplay),
+                      FALSE, &n);
+
+  if (n == -1)
+    return;
+
+  for (i = 0; i < n; i++)
+    {
+      if (m[i].noutput > 1)
+        XRRDeleteMonitor (manager->priv->xdisplay,
+                          DefaultRootWindow (manager->priv->xdisplay),
+                          m[i].name);
+    }
+
+  XRRFreeMonitors (m);
+#endif
+}
+
 static GdkFilterReturn
 filter_func (GdkXEvent *xevent,
              GdkEvent  *event,
@@ -134,9 +226,10 @@ meta_monitor_transform_to_xrandr (MetaMonitorTransform transform)
       return RR_Reflect_X | RR_Rotate_180;
     case META_MONITOR_TRANSFORM_FLIPPED_270:
       return RR_Reflect_X | RR_Rotate_270;
+    default:
+      g_assert_not_reached ();
+      break;
     }
-
-  g_assert_not_reached ();
 }
 
 static MetaMonitorTransform
@@ -313,11 +406,91 @@ output_set_presentation_xrandr (FlashbackMonitorManagerPrivate *priv,
 
   value = presentation;
   atom = XInternAtom (priv->xdisplay, "_GNOME_FLASHBACK_PRESENTATION_OUTPUT", False);
-  XRRChangeOutputProperty (priv->xdisplay,
-                           (XID) output->winsys_id,
-                           atom,
-                           XA_CARDINAL, 32, PropModeReplace,
-                           (unsigned char*) &value, 1);
+  xcb_randr_change_output_property (XGetXCBConnection (priv->xdisplay),
+                                    (XID) output->winsys_id,
+                                    atom, XCB_ATOM_CARDINAL, 32,
+                                    XCB_PROP_MODE_REPLACE,
+                                    1, &value);
+}
+
+static gboolean
+output_get_underscanning_xrandr (FlashbackMonitorManagerPrivate *priv,
+                                 MetaOutput                     *output)
+{
+  gboolean value = FALSE;
+  Atom atom, actual_type;
+  int actual_format;
+  unsigned long nitems, bytes_after;
+  unsigned char *buffer;
+  char *str;
+
+  atom = XInternAtom (priv->xdisplay, "underscan", False);
+  XRRGetOutputProperty (priv->xdisplay,
+                        (XID)output->winsys_id,
+                        atom,
+                        0, G_MAXLONG, False, False, XA_ATOM,
+                        &actual_type, &actual_format,
+                        &nitems, &bytes_after, &buffer);
+
+  if (actual_type != XA_ATOM || actual_format != 32 ||
+      nitems < 1)
+    goto out;
+
+  str = XGetAtomName (priv->xdisplay, *(Atom *)buffer);
+  value = !strcmp(str, "on");
+  XFree (str);
+
+out:
+  XFree (buffer);
+  return value;
+}
+
+static gboolean
+output_get_supports_underscanning_xrandr (FlashbackMonitorManagerPrivate *priv,
+                                          MetaOutput                     *output)
+{
+  Atom atom, actual_type;
+  int actual_format, i;
+  unsigned long nitems, bytes_after;
+  unsigned char *buffer;
+  XRRPropertyInfo *property_info;
+  Atom *values;
+  gboolean supports_underscanning = FALSE;
+
+  atom = XInternAtom (priv->xdisplay, "underscan", False);
+  XRRGetOutputProperty (priv->xdisplay,
+                        (XID)output->winsys_id,
+                        atom,
+                        0, G_MAXLONG, False, False, XA_ATOM,
+                        &actual_type, &actual_format,
+                        &nitems, &bytes_after, &buffer);
+
+  if (actual_type != XA_ATOM || actual_format != 32 || nitems < 1)
+    {
+      XFree (buffer);
+      return FALSE;
+    }
+
+  property_info = XRRQueryOutputProperty (priv->xdisplay,
+                                          (XID) output->winsys_id,
+                                          atom);
+  values = (Atom *) property_info->values;
+
+  for (i = 0; i < property_info->num_values; i++)
+    {
+      /* The output supports underscanning if "on" is a valid value
+       * for the underscan property.
+       */
+      char *name = XGetAtomName (priv->xdisplay, values[i]);
+      if (strcmp (name, "on") == 0)
+        supports_underscanning = TRUE;
+
+      XFree (name);
+    }
+
+  XFree (property_info);
+
+  return supports_underscanning;
 }
 
 static int
@@ -367,6 +540,7 @@ output_get_backlight_limits_xrandr (FlashbackMonitorManagerPrivate *priv,
   Atom atom;
   xcb_connection_t *xcb_conn;
   xcb_randr_query_output_property_reply_t *reply;
+  int32_t *values;
 
   atom = XInternAtom (priv->xdisplay, "Backlight", False);
 
@@ -387,7 +561,7 @@ output_get_backlight_limits_xrandr (FlashbackMonitorManagerPrivate *priv,
       goto out;
     }
 
-  int32_t *values = xcb_randr_query_output_property_valid_values (reply);
+  values = xcb_randr_query_output_property_valid_values (reply);
   output->backlight_min = values[0];
   output->backlight_max = values[1];
 
@@ -395,6 +569,42 @@ out:
   free (reply);
 }
 
+static void
+output_get_tile_info (FlashbackMonitorManagerPrivate *priv,
+                      MetaOutput                     *output)
+{
+  Atom tile_atom;
+  unsigned char *prop;
+  unsigned long nitems, bytes_after;
+  int actual_format;
+  Atom actual_type;
+
+  if (priv->has_randr15 == FALSE)
+    return;
+
+  tile_atom = XInternAtom (priv->xdisplay, "TILE", FALSE);
+  XRRGetOutputProperty (priv->xdisplay, output->winsys_id,
+                        tile_atom, 0, 100, False,
+                        False, AnyPropertyType,
+                        &actual_type, &actual_format,
+                        &nitems, &bytes_after, &prop);
+
+  if (actual_type == XA_INTEGER && actual_format == 32 && nitems == 8)
+    {
+      long *values = (long *)prop;
+      output->tile_info.group_id = values[0];
+      output->tile_info.flags = values[1];
+      output->tile_info.max_h_tiles = values[2];
+      output->tile_info.max_v_tiles = values[3];
+      output->tile_info.loc_h_tile = values[4];
+      output->tile_info.loc_v_tile = values[5];
+      output->tile_info.tile_w = values[6];
+      output->tile_info.tile_h = values[7];
+    }
+
+  XFree (prop);
+}
+
 static gboolean
 output_get_hotplug_mode_update (FlashbackMonitorManagerPrivate *priv,
                                 MetaOutput                     *output)
@@ -526,7 +736,7 @@ output_get_connector_type_from_name (FlashbackMonitorManagerPrivate *priv,
   if (g_str_has_prefix (name, "Virtual"))
     return META_CONNECTOR_TYPE_VIRTUAL;
   if (g_str_has_prefix (name, "Composite"))
-    return META_CONNECTOR_TYPE_VGA;
+    return META_CONNECTOR_TYPE_Composite;
   if (g_str_has_prefix (name, "S-video"))
     return META_CONNECTOR_TYPE_SVIDEO;
   if (g_str_has_prefix (name, "TV"))
@@ -585,11 +795,105 @@ get_xmode_name (XRRModeInfo *xmode)
 }
 
 static gboolean
-gdk_rectangle_equal (const GdkRectangle *src1,
-                     const GdkRectangle *src2)
+gdk_rectangle_contains_rect (const GdkRectangle *outer_rect,
+                             const GdkRectangle *inner_rect)
+{
+  return inner_rect->x                      >= outer_rect->x &&
+         inner_rect->y                      >= outer_rect->y &&
+         inner_rect->x + inner_rect->width  <= outer_rect->x + outer_rect->width &&
+         inner_rect->y + inner_rect->height <= outer_rect->y + outer_rect->height;
+}
+
+/*
+ * rules for constructing a tiled monitor
+ * 1. find a tile_group_id
+ * 2. iterate over all outputs for that tile group id
+ * 3. see if output has a crtc and if it is configured for the tile size
+ * 4. calculate the total tile size
+ * 5. set tile finished size
+ * 6. check for more tile_group_id
+*/
+static void
+construct_tile_monitor (FlashbackMonitorManager *manager,
+                        GArray                  *monitor_infos,
+                        guint32                  tile_group_id)
 {
-  return ((src1->x == src2->x) && (src1->y == src2->y) &&
-          (src1->width == src2->width) && (src1->height == src2->height));
+  MetaMonitorInfo info;
+  unsigned i;
+
+  for (i = 0; i < monitor_infos->len; i++)
+    {
+      MetaMonitorInfo *pinfo = &g_array_index (monitor_infos, MetaMonitorInfo, i);
+
+      if (pinfo->tile_group_id == tile_group_id)
+        return;
+    }
+
+  /* didn't find it */
+  info.number = monitor_infos->len;
+  info.tile_group_id = tile_group_id;
+  info.is_presentation = FALSE;
+  info.refresh_rate = 0.0;
+  info.width_mm = 0;
+  info.height_mm = 0;
+  info.is_primary = FALSE;
+  info.rect.x = INT_MAX;
+  info.rect.y = INT_MAX;
+  info.rect.width = 0;
+  info.rect.height = 0;
+  info.winsys_id = 0;
+  info.n_outputs = 0;
+  info.monitor_winsys_xid = 0;
+
+  for (i = 0; i < manager->n_outputs; i++)
+    {
+      MetaOutput *output = &manager->outputs[i];
+
+      if (!output->tile_info.group_id)
+        continue;
+
+      if (output->tile_info.group_id != tile_group_id)
+        continue;
+
+      if (!output->crtc)
+        continue;
+
+      if (output->crtc->rect.width != (int)output->tile_info.tile_w ||
+          output->crtc->rect.height != (int)output->tile_info.tile_h)
+        continue;
+
+      if (output->tile_info.loc_h_tile == 0 && output->tile_info.loc_v_tile == 0)
+        {
+          info.refresh_rate = output->crtc->current_mode->refresh_rate;
+          info.width_mm = output->width_mm;
+          info.height_mm = output->height_mm;
+          info.winsys_id = output->winsys_id;
+        }
+
+      /* hack */
+      if (output->crtc->rect.x < info.rect.x)
+        info.rect.x = output->crtc->rect.x;
+      if (output->crtc->rect.y < info.rect.y)
+        info.rect.y = output->crtc->rect.y;
+
+      if (output->tile_info.loc_h_tile == 0)
+        info.rect.height += output->tile_info.tile_h;
+
+      if (output->tile_info.loc_v_tile == 0)
+        info.rect.width += output->tile_info.tile_w;
+
+      if (info.n_outputs > META_MAX_OUTPUTS_PER_MONITOR)
+        continue;
+
+      info.outputs[info.n_outputs++] = output;
+    }
+
+  /* if we don't have a winsys id, i.e. we haven't found tile 0,0
+     don't try and add this to the monitor infos */
+  if (!info.winsys_id)
+    return;
+
+  g_array_append_val (monitor_infos, info);
 }
 
 /*
@@ -612,6 +916,16 @@ make_logical_config (FlashbackMonitorManager *manager)
      for each of them, unless they reference a rectangle that
      is already there.
   */
+
+  /* for tiling we need to work out how many tiled outputs there are */
+  for (i = 0; i < manager->n_outputs; i++)
+    {
+      MetaOutput *output = &manager->outputs[i];
+
+      if (output->tile_info.group_id)
+        construct_tile_monitor (manager, monitor_infos, output->tile_info.group_id);
+    }
+
   for (i = 0; i < manager->n_crtcs; i++)
     {
       MetaCRTC *crtc = &manager->crtcs[i];
@@ -623,7 +937,7 @@ make_logical_config (FlashbackMonitorManager *manager)
       for (j = 0; j < monitor_infos->len; j++)
         {
           MetaMonitorInfo *info = &g_array_index (monitor_infos, MetaMonitorInfo, j);
-          if (gdk_rectangle_equal (&crtc->rect, &info->rect))
+          if (gdk_rectangle_contains_rect (&crtc->rect, &info->rect))
             {
               crtc->logical_monitor = info;
               break;
@@ -635,7 +949,9 @@ make_logical_config (FlashbackMonitorManager *manager)
           MetaMonitorInfo info;
 
           info.number = monitor_infos->len;
+          info.tile_group_id = 0;
           info.rect = crtc->rect;
+          info.refresh_rate = crtc->current_mode->refresh_rate;
           info.is_primary = FALSE;
           /* This starts true because we want
              is_presentation only if all outputs are
@@ -646,6 +962,9 @@ make_logical_config (FlashbackMonitorManager *manager)
           info.in_fullscreen = -1;
           info.winsys_id = 0;
 
+          info.n_outputs = 0;
+          info.monitor_winsys_xid = 0;
+
           g_array_append_val (monitor_infos, info);
 
           crtc->logical_monitor = &g_array_index (monitor_infos, MetaMonitorInfo,
@@ -667,6 +986,9 @@ make_logical_config (FlashbackMonitorManager *manager)
       if (output->crtc == NULL)
         continue;
 
+      if (output->tile_info.group_id)
+        continue;
+
       /* We must have a logical monitor on every CRTC at this point */
       g_assert (output->crtc->logical_monitor != NULL);
 
@@ -675,6 +997,12 @@ make_logical_config (FlashbackMonitorManager *manager)
       info->is_primary = info->is_primary || output->is_primary;
       info->is_presentation = info->is_presentation && output->is_presentation;
 
+      info->width_mm = output->width_mm;
+      info->height_mm = output->height_mm;
+
+      info->outputs[0] = output;
+      info->n_outputs = 1;
+
       if (output->is_primary || info->winsys_id == 0)
         info->winsys_id = output->winsys_id;
 
@@ -684,6 +1012,9 @@ make_logical_config (FlashbackMonitorManager *manager)
 
   manager->n_monitor_infos = monitor_infos->len;
   manager->monitor_infos = (void*)g_array_free (monitor_infos, FALSE);
+
+  for (i = 0; i < manager->n_monitor_infos; i++)
+    add_monitor (manager, &manager->monitor_infos[i]);
 }
 
 static void
@@ -945,6 +1276,8 @@ read_current_config (FlashbackMonitorManager *manager)
           meta_output->suggested_y = output_get_suggested_y (priv, meta_output);
           meta_output->connector_type = output_get_connector_type (priv, meta_output);
 
+          output_get_tile_info (priv, meta_output);
+
           meta_output->n_modes = output->nmode;
           meta_output->modes = g_new0 (MetaMonitorMode *, meta_output->n_modes);
 
@@ -1001,6 +1334,8 @@ read_current_config (FlashbackMonitorManager *manager)
 
           meta_output->is_primary = ((XID)meta_output->winsys_id == primary_output);
           meta_output->is_presentation = output_get_presentation_xrandr (priv, meta_output);
+          meta_output->is_underscanning = output_get_underscanning_xrandr (priv, meta_output);
+          meta_output->supports_underscanning = output_get_supports_underscanning_xrandr (priv, meta_output);
           output_get_backlight_limits_xrandr (priv, meta_output);
 
         if (!(meta_output->backlight_min == 0 && meta_output->backlight_max == 0))
@@ -1166,6 +1501,8 @@ static void
 flashback_monitor_manager_init (FlashbackMonitorManager *manager)
 {
   FlashbackMonitorManagerPrivate *priv;
+  int major_version;
+  int minor_version;
 
   priv = flashback_monitor_manager_get_instance_private (manager);
   manager->priv = priv;
@@ -1182,6 +1519,17 @@ flashback_monitor_manager_init (FlashbackMonitorManager *manager)
   XRRSelectInput (priv->xdisplay, DefaultRootWindow (priv->xdisplay),
                   RRScreenChangeNotifyMask | RRCrtcChangeNotifyMask |
                   RROutputPropertyNotifyMask);
+
+  priv->has_randr15 = FALSE;
+
+  XRRQueryVersion (priv->xdisplay, &major_version, &minor_version);
+
+#ifdef HAVE_XRANDR15
+  if (major_version > 1 || (major_version == 1 && minor_version >= 5))
+    priv->has_randr15 = TRUE;
+#endif
+
+  init_monitors (manager);
 }
 
 FlashbackMonitorManager *
@@ -1192,6 +1540,52 @@ flashback_monitor_manager_new (MetaDBusDisplayConfig *display_config)
                        NULL);
 }
 
+static void
+output_set_underscanning_xrandr (FlashbackMonitorManagerPrivate *priv,
+                                 MetaOutput                     *output,
+                                 gboolean                        underscanning)
+{
+  Atom prop, valueatom;
+  const char *value;
+
+  prop = XInternAtom (priv->xdisplay, "underscan", False);
+
+  value = underscanning ? "on" : "off";
+  valueatom = XInternAtom (priv->xdisplay, value, False);
+
+  xcb_randr_change_output_property (XGetXCBConnection (priv->xdisplay),
+                                    (XID) output->winsys_id,
+                                    prop, XCB_ATOM_ATOM, 32,
+                                    XCB_PROP_MODE_REPLACE,
+                                    1, &valueatom);
+
+  /* Configure the border at the same time. Currently, we use a
+   * 5% of the width/height of the mode. In the future, we should
+   * make the border configurable. */
+  if (underscanning)
+    {
+      uint32_t border_value;
+
+      prop = XInternAtom (priv->xdisplay, "underscan hborder", False);
+      border_value = output->crtc->current_mode->width * 0.05;
+
+      xcb_randr_change_output_property (XGetXCBConnection (priv->xdisplay),
+                                        (XID) output->winsys_id,
+                                        prop, XCB_ATOM_INTEGER, 32,
+                                        XCB_PROP_MODE_REPLACE,
+                                        1, &border_value);
+
+      prop = XInternAtom (priv->xdisplay, "underscan vborder", False);
+      border_value = output->crtc->current_mode->height * 0.05;
+
+      xcb_randr_change_output_property (XGetXCBConnection (priv->xdisplay),
+                                        (XID) output->winsys_id,
+                                        prop, XCB_ATOM_INTEGER, 32,
+                                        XCB_PROP_MODE_REPLACE,
+                                        1, &border_value);
+    }
+}
+
 void
 flashback_monitor_manager_apply_configuration (FlashbackMonitorManager  *manager,
                                                MetaCRTCInfo            **crtcs,
@@ -1313,17 +1707,16 @@ flashback_monitor_manager_apply_configuration (FlashbackMonitorManager  *manager
       if (crtc_info->mode != NULL)
         {
           MetaMonitorMode *mode;
-          XID *outputs;
-          unsigned int j, n_outputs;
-          int width, height;
+          XID *xids;
+          unsigned int j, n_xids;
           Status ok;
 
           mode = crtc_info->mode;
 
-          n_outputs = crtc_info->outputs->len;
-          outputs = g_new (XID, n_outputs);
+          n_xids = crtc_info->outputs->len;
+          xids = g_new (XID, n_xids);
 
-          for (j = 0; j < n_outputs; j++)
+          for (j = 0; j < n_xids; j++)
             {
               MetaOutput *output;
 
@@ -1332,7 +1725,7 @@ flashback_monitor_manager_apply_configuration (FlashbackMonitorManager  *manager
               output->is_dirty = TRUE;
               output->crtc = crtc;
 
-              outputs[j] = output->winsys_id;
+              xids[j] = output->winsys_id;
             }
 
           ok = XRRSetCrtcConfig (priv->xdisplay,
@@ -1342,7 +1735,7 @@ flashback_monitor_manager_apply_configuration (FlashbackMonitorManager  *manager
                                  crtc_info->x, crtc_info->y,
                                  (XID) mode->mode_id,
                                  meta_monitor_transform_to_xrandr (crtc_info->transform),
-                                 outputs, n_outputs);
+                                 xids, n_xids);
 
           if (ok != Success)
             {
@@ -1372,7 +1765,7 @@ flashback_monitor_manager_apply_configuration (FlashbackMonitorManager  *manager
           crtc->transform = crtc_info->transform;
 
         next:
-          g_free (outputs);
+          g_free (xids);
         }
     }
 
@@ -1392,8 +1785,14 @@ flashback_monitor_manager_apply_configuration (FlashbackMonitorManager  *manager
                                       output_info->output,
                                       output_info->is_presentation);
 
+      if (output_get_supports_underscanning_xrandr (priv, output_info->output))
+        output_set_underscanning_xrandr (priv,
+                                         output_info->output,
+                                         output_info->is_underscanning);
+
       output->is_primary = output_info->is_primary;
       output->is_presentation = output_info->is_presentation;
+      output->is_underscanning = output_info->is_underscanning;
     }
 
   /* Disable outputs not mentioned in the list */
@@ -1447,11 +1846,12 @@ flashback_monitor_manager_change_backlight (FlashbackMonitorManager *manager,
   hw_value = round ((double)value / 100.0 * output->backlight_max + output->backlight_min);
 
   atom = XInternAtom (priv->xdisplay, "Backlight", False);
-  XRRChangeOutputProperty (priv->xdisplay,
-                           (XID) output->winsys_id,
-                           atom,
-                           XA_INTEGER, 32, PropModeReplace,
-                           (unsigned char *) &hw_value, 1);
+
+  xcb_randr_change_output_property (XGetXCBConnection (priv->xdisplay),
+                                    (XID) output->winsys_id,
+                                    atom, XCB_ATOM_INTEGER, 32,
+                                    XCB_PROP_MODE_REPLACE,
+                                    1, &hw_value);
 
   /* We're not selecting for property notifies, so update the value immediately */
   output->backlight = normalize_backlight (output, hw_value);
@@ -1517,6 +1917,7 @@ flashback_monitor_manager_set_power_save_mode (FlashbackMonitorManager *manager,
     case META_POWER_SAVE_OFF:
       state = DPMSModeOff;
       break;
+    case META_POWER_SAVE_UNSUPPORTED:
     default:
       return;
   }
@@ -1683,14 +2084,34 @@ void
 flashback_monitor_manager_rebuild_derived (FlashbackMonitorManager *manager)
 {
   MetaMonitorInfo *old_monitor_infos;
+  unsigned old_n_monitor_infos;
+  unsigned i, j;
 
   old_monitor_infos = manager->monitor_infos;
+  old_n_monitor_infos = manager->n_monitor_infos;
 
   if (manager->in_init)
     return;
 
   make_logical_config (manager);
 
+  for (i = 0; i < old_n_monitor_infos; i++)
+    {
+      gboolean delete_mon = TRUE;
+
+      for (j = 0; j < manager->n_monitor_infos; j++)
+        {
+          if (manager->monitor_infos[j].monitor_winsys_xid == old_monitor_infos[i].monitor_winsys_xid)
+            {
+              delete_mon = FALSE;
+              break;
+            }
+        }
+
+      if (delete_mon)
+        remove_monitor (manager, old_monitor_infos[i].monitor_winsys_xid);
+    }
+
   g_signal_emit_by_name (manager->priv->display_config, "monitors-changed");
 
   g_free (old_monitor_infos);
diff --git a/gnome-flashback/libdisplay-config/flashback-monitor-manager.h b/gnome-flashback/libdisplay-config/flashback-monitor-manager.h
index 4ea3db0..774034c 100644
--- a/gnome-flashback/libdisplay-config/flashback-monitor-manager.h
+++ b/gnome-flashback/libdisplay-config/flashback-monitor-manager.h
@@ -41,6 +41,7 @@ typedef struct _MetaMonitorMode MetaMonitorMode;
 typedef struct _MetaMonitorInfo MetaMonitorInfo;
 typedef struct _MetaCRTCInfo    MetaCRTCInfo;
 typedef struct _MetaOutputInfo  MetaOutputInfo;
+typedef struct _MetaTileInfo    MetaTileInfo;
 
 typedef enum {
   META_MONITOR_TRANSFORM_NORMAL,
@@ -74,6 +75,17 @@ typedef enum {
   META_CONNECTOR_TYPE_DSI         = 16,
 } MetaConnectorType;
 
+struct _MetaTileInfo {
+  guint32 group_id;
+  guint32 flags;
+  guint32 max_h_tiles;
+  guint32 max_v_tiles;
+  guint32 loc_h_tile;
+  guint32 loc_v_tile;
+  guint32 tile_w;
+  guint32 tile_h;
+};
+
 struct _MetaOutput
 {
   /* The CRTC driving this output, NULL if the output is not enabled */
@@ -112,6 +124,8 @@ struct _MetaOutput
   */
   gboolean            is_primary;
   gboolean            is_presentation;
+  gboolean            is_underscanning;
+  gboolean            supports_underscanning;
 
   gpointer            driver_private;
   GDestroyNotify      driver_notify;
@@ -120,6 +134,8 @@ struct _MetaOutput
   gboolean            hotplug_mode_update;
   gint                suggested_x;
   gint                suggested_y;
+
+  MetaTileInfo        tile_info;
 };
 
 struct _MetaCRTC
@@ -153,6 +169,8 @@ struct _MetaMonitorMode
   GDestroyNotify driver_notify;
 };
 
+#define META_MAX_OUTPUTS_PER_MONITOR 4
+
 /**
  * MetaMonitorInfo:
  *
@@ -168,6 +186,10 @@ struct _MetaMonitorInfo
   int          number;
   int          xinerama_index;
   GdkRectangle rect;
+  /* for tiled monitors these are calculated, from untiled just copied */
+  float        refresh_rate;
+  int          width_mm;
+  int          height_mm;
   gboolean     is_primary;
   gboolean     is_presentation; /* XXX: not yet used */
   gboolean     in_fullscreen;
@@ -181,6 +203,12 @@ struct _MetaMonitorInfo
      the primary one).
   */
   glong        winsys_id;
+
+  guint32      tile_group_id;
+
+  int          monitor_winsys_xid;
+  int          n_outputs;
+  MetaOutput  *outputs[META_MAX_OUTPUTS_PER_MONITOR];
 };
 
 /*
@@ -210,6 +238,7 @@ struct _MetaOutputInfo
   MetaOutput *output;
   gboolean    is_primary;
   gboolean    is_presentation;
+  gboolean    is_underscanning;
 };
 
 #define FLASHBACK_TYPE_MONITOR_MANAGER flashback_monitor_manager_get_type ()
diff --git a/gnome-flashback/libend-session-dialog/Makefile.am b/gnome-flashback/libend-session-dialog/Makefile.am
index 9d3ba3d..ce4c114 100644
--- a/gnome-flashback/libend-session-dialog/Makefile.am
+++ b/gnome-flashback/libend-session-dialog/Makefile.am
@@ -1,10 +1,16 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libend-session-dialog.la
+	libend-session-dialog.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libend_session_dialog_la_CFLAGS = \
 	$(END_SESSION_DIALOG_CFLAGS) \
-	-I$(top_builddir)/gnome-flashback/libend-session-dailog \
-	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\"
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
+	-I$(top_builddir)/gnome-flashback/libend-session-dialog \
+	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\" \
+	$(NULL)
 
 libend_session_dialog_la_SOURCES = \
 	dbus-end-session-dialog.c \
@@ -12,10 +18,17 @@ libend_session_dialog_la_SOURCES = \
 	flashback-end-session-dialog.c \
 	flashback-end-session-dialog.h \
 	flashback-inhibit-dialog.c \
-	flashback-inhibit-dialog.h
+	flashback-inhibit-dialog.h \
+	$(NULL)
+
+libend_session_dialog_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libend_session_dialog_la_LIBADD = \
-	$(END_SESSION_DIALOG_LIBS)
+	$(END_SESSION_DIALOG_LIBS) \
+	$(NULL)
 
 dbus-end-session-dialog.h:
 dbus-end-session-dialog.c: org.gnome.SessionManager.EndSessionDialog.xml Makefile.am
@@ -27,13 +40,16 @@ dbus-end-session-dialog.c: org.gnome.SessionManager.EndSessionDialog.xml Makefil
 
 BUILT_SOURCES = \
 	dbus-end-session-dialog.h \
-	dbus-end-session-dialog.c
+	dbus-end-session-dialog.c \
+	$(NULL)
 
 EXTRA_DIST = \
 	org.gnome.SessionManager.EndSessionDialog.xml \
-	flashback-inhibit-dialog.ui
+	flashback-inhibit-dialog.ui \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libend-session-dialog/flashback-inhibit-dialog.c b/gnome-flashback/libend-session-dialog/flashback-inhibit-dialog.c
index 8d10848..f3f8f60 100644
--- a/gnome-flashback/libend-session-dialog/flashback-inhibit-dialog.c
+++ b/gnome-flashback/libend-session-dialog/flashback-inhibit-dialog.c
@@ -101,9 +101,6 @@ static void
 flashback_inhibit_dialog_set_inhibitor_paths (FlashbackInhibitDialog *dialog,
                                               const gchar *const     *paths)
 {
-	const gchar *const *old_paths;
-
-	old_paths = dialog->priv->inhibitor_paths;
 	dialog->priv->inhibitor_paths = (const gchar *const *) g_strdupv ((gchar **) paths);
 
 	if (dialog->priv->list_store == NULL) {
@@ -359,7 +356,7 @@ model_is_empty (GtkTreeModel *model)
 	return gtk_tree_model_iter_n_children (model, NULL) == 0;
 }
 
-char *
+static char *
 get_user_name (void)
 {
 	char *name;
@@ -383,7 +380,6 @@ update_dialog_text (FlashbackInhibitDialog *dialog)
 	gboolean     inhibited;
 	gint         seconds;
 	const gchar *title;
-	const gchar *tmp;
 	gchar       *description;
 
 	inhibited = !model_is_empty (GTK_TREE_MODEL (dialog->priv->list_store));
@@ -408,49 +404,49 @@ update_dialog_text (FlashbackInhibitDialog *dialog)
 		if (inhibited) {
 			description = g_strdup (_("Click Log Out to quit these applications and log out of the system."));
 		} else {
-			tmp = ngettext ("%s will be logged out automatically in %d second.",
-			                "%s will be logged out automatically in %d seconds.",
-			                seconds);
-			description = g_strdup_printf (tmp, get_user_name (), seconds);
+			description = g_strdup_printf (ngettext ("%s will be logged out automatically in %d second.",
+			                                         "%s will be logged out automatically in %d seconds.",
+			                                         seconds),
+			                               get_user_name (), seconds);
 		}
 	} else if (dialog->priv->action == FLASHBACK_LOGOUT_ACTION_SHUTDOWN) {
 		title = _("Power Off");
 		if (inhibited) {
 			description = g_strdup (_("Click Power Off to quit these applications and power off the system."));
 		} else {
-			tmp = ngettext ("The system will power off automatically in %d second.",
-			                "The system will power off automatically in %d seconds.",
-			                seconds);
-			description = g_strdup_printf (tmp, seconds);
+			description = g_strdup_printf (ngettext ("The system will power off automatically in %d second.",
+			                                         "The system will power off automatically in %d seconds.",
+			                                         seconds),
+			                               seconds);
 		}
 	} else if (dialog->priv->action == FLASHBACK_LOGOUT_ACTION_REBOOT) {
 		title = _("Restart");
 		if (inhibited) {
 			description = g_strdup (_("Click Restart to quit these applications and restart the system."));
 		} else {
-			tmp = ngettext ("The system will restart automatically in %d second.",
-			                "The system will restart automatically in %d seconds.",
-			                seconds);
-			description = g_strdup_printf (tmp, seconds);
+			description = g_strdup_printf (ngettext ("The system will restart automatically in %d second.",
+			                                         "The system will restart automatically in %d seconds.",
+			                                         seconds),
+			                               seconds);
 		}
 	} else if (dialog->priv->action == FLASHBACK_LOGOUT_ACTION_HIBERNATE) {
 		title = _("Hibernate");
-		tmp = ngettext ("The system will hibernate automatically in %d second.",
-		                "The system will hibernate automatically in %d seconds.",
-		                seconds);
-		description = g_strdup_printf (tmp, seconds);
+		description = g_strdup_printf (ngettext ("The system will hibernate automatically in %d second.",
+		                                         "The system will hibernate automatically in %d seconds.",
+		                                         seconds),
+		                               seconds);
 	} else if (dialog->priv->action == FLASHBACK_LOGOUT_ACTION_SUSPEND) {
 		title = _("Suspend");
-		tmp = ngettext ("The system will suspend automatically in %d second.",
-		                "The system will suspend automatically in %d seconds.",
-		                seconds);
-		description = g_strdup_printf (tmp, seconds);
+		description = g_strdup_printf (ngettext ("The system will suspend automatically in %d second.",
+		                                         "The system will suspend automatically in %d seconds.",
+		                                         seconds),
+		                               seconds);
 	} else if (dialog->priv->action == FLASHBACK_LOGOUT_ACTION_HYBRID_SLEEP) {
 		title = _("Hybrid Sleep");
-		tmp = ngettext ("The system will hybrid sleep automatically in %d second.",
-		                "The system will hybrid sleep automatically in %d seconds.",
-		                seconds);
-		description = g_strdup_printf (tmp, seconds);
+		description = g_strdup_printf (ngettext ("The system will hybrid sleep automatically in %d second.",
+		                                         "The system will hybrid sleep automatically in %d seconds.",
+		                                         seconds),
+		                               seconds);
 	} else {
 		g_assert_not_reached ();
 	}
diff --git a/gnome-flashback/libidle-monitor/Makefile.am b/gnome-flashback/libidle-monitor/Makefile.am
index 22d083d..ca39c14 100644
--- a/gnome-flashback/libidle-monitor/Makefile.am
+++ b/gnome-flashback/libidle-monitor/Makefile.am
@@ -1,24 +1,37 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libidle-monitor.la
+	libidle-monitor.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libidle_monitor_la_CFLAGS = \
 	$(IDLE_MONITOR_CFLAGS) \
-	-I$(top_builddir)/gnome-flashback/libidle-monitor
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
+	-I$(top_builddir)/gnome-flashback/libidle-monitor \
+	$(NULL)
 
 libidle_monitor_la_SOURCES = \
+	flashback-idle-monitor.c \
+	flashback-idle-monitor.h \
 	meta-dbus-idle-monitor.c \
 	meta-dbus-idle-monitor.h \
 	meta-backend.c \
 	meta-backend.h \
 	meta-idle-monitor.c \
 	meta-idle-monitor.h \
-	meta-idle-monitor-dbus.c \
-	meta-idle-monitor-dbus.h \
 	meta-idle-monitor-xsync.c \
-	meta-idle-monitor-xsync.h
+	meta-idle-monitor-xsync.h \
+	$(NULL)
+
+libidle_monitor_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libidle_monitor_la_LIBADD = \
-	$(IDLE_MONITOR_LIBS)
+	$(IDLE_MONITOR_LIBS) \
+	$(NULL)
 
 meta-dbus-idle-monitor.h:
 meta-dbus-idle-monitor.c: org.gnome.Mutter.IdleMonitor.xml
@@ -31,12 +44,15 @@ meta-dbus-idle-monitor.c: org.gnome.Mutter.IdleMonitor.xml
 
 BUILT_SOURCES = \
 	meta-dbus-idle-monitor.h \
-	meta-dbus-idle-monitor.c
+	meta-dbus-idle-monitor.c \
+	$(NULL)
 
 EXTRA_DIST = \
-	org.gnome.Mutter.IdleMonitor.xml
+	org.gnome.Mutter.IdleMonitor.xml \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libidle-monitor/flashback-idle-monitor.c b/gnome-flashback/libidle-monitor/flashback-idle-monitor.c
new file mode 100644
index 0000000..77cc37c
--- /dev/null
+++ b/gnome-flashback/libidle-monitor/flashback-idle-monitor.c
@@ -0,0 +1,472 @@
+/*
+ * Copyright (C) 2013 Red Hat, Inc.
+ * Copyright (C) 2015 Alberts Muktupāvels
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Adapted from gnome-session/gnome-session/gs-idle-monitor.c and
+ *         from gnome-desktop/libgnome-desktop/gnome-idle-monitor.c
+ */
+
+#include "config.h"
+
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <X11/extensions/sync.h>
+
+#include "flashback-idle-monitor.h"
+#include "meta-backend.h"
+#include "meta-idle-monitor.h"
+#include "meta-idle-monitor-xsync.h"
+#include "meta-dbus-idle-monitor.h"
+
+struct _FlashbackIdleMonitor
+{
+  GObject                   parent;
+
+  gint                      dbus_name_id;
+
+  gint                      xsync_event_base;
+  gint                      xsync_error_base;
+
+  GDBusObjectManagerServer *server;
+};
+
+G_DEFINE_TYPE (FlashbackIdleMonitor, flashback_idle_monitor, G_TYPE_OBJECT)
+
+static gboolean
+handle_get_idletime (MetaDBusIdleMonitor   *skeleton,
+                     GDBusMethodInvocation *invocation,
+                     MetaIdleMonitor       *monitor)
+{
+  guint64 idletime;
+
+  idletime = meta_idle_monitor_get_idletime (monitor);
+  meta_dbus_idle_monitor_complete_get_idletime (skeleton, invocation, idletime);
+
+  return TRUE;
+}
+
+typedef struct {
+  MetaDBusIdleMonitor *dbus_monitor;
+  MetaIdleMonitor *monitor;
+  char *dbus_name;
+  guint watch_id;
+  guint name_watcher_id;
+} DBusWatch;
+
+static void
+destroy_dbus_watch (gpointer data)
+{
+  DBusWatch *watch = data;
+
+  g_object_unref (watch->dbus_monitor);
+  g_object_unref (watch->monitor);
+  g_free (watch->dbus_name);
+  g_bus_unwatch_name (watch->name_watcher_id);
+
+  g_slice_free (DBusWatch, watch);
+}
+
+static void
+dbus_idle_callback (MetaIdleMonitor *monitor,
+                    guint            watch_id,
+                    gpointer         user_data)
+{
+  DBusWatch *watch;
+  GDBusInterfaceSkeleton *skeleton;
+  GDBusConnection *connection;
+  const gchar *path;
+
+  watch = (DBusWatch *) user_data;
+  skeleton = G_DBUS_INTERFACE_SKELETON (watch->dbus_monitor);
+  connection = g_dbus_interface_skeleton_get_connection (skeleton);
+  path = g_dbus_interface_skeleton_get_object_path (skeleton);
+
+  if (connection == NULL)
+    return;
+
+  g_dbus_connection_emit_signal (connection, watch->dbus_name, path,
+                                 "org.gnome.Mutter.IdleMonitor",
+                                 "WatchFired", g_variant_new ("(u)", watch_id),
+                                 NULL);
+}
+
+static void
+name_vanished_callback (GDBusConnection *connection,
+                        const char      *name,
+                        gpointer         user_data)
+{
+  DBusWatch *watch = user_data;
+
+  meta_idle_monitor_remove_watch (watch->monitor, watch->watch_id);
+}
+
+static DBusWatch *
+make_dbus_watch (MetaDBusIdleMonitor   *skeleton,
+                 GDBusMethodInvocation *invocation,
+                 MetaIdleMonitor       *monitor)
+{
+  GDBusConnection *connection;
+  const gchar *sender;
+  DBusWatch *watch;
+
+  connection = g_dbus_method_invocation_get_connection (invocation);
+  sender = g_dbus_method_invocation_get_sender (invocation);
+
+  watch = g_slice_new (DBusWatch);
+  watch->dbus_monitor = g_object_ref (skeleton);
+  watch->monitor = g_object_ref (monitor);
+  watch->dbus_name = g_strdup (sender);
+  watch->name_watcher_id = g_bus_watch_name_on_connection (connection,
+                                                           watch->dbus_name,
+                                                           G_BUS_NAME_WATCHER_FLAGS_NONE,
+                                                           NULL, /* appeared */
+                                                           name_vanished_callback,
+                                                           watch, NULL);
+
+  return watch;
+}
+
+static gboolean
+handle_add_idle_watch (MetaDBusIdleMonitor   *skeleton,
+                       GDBusMethodInvocation *invocation,
+                       guint64                interval,
+                       MetaIdleMonitor       *monitor)
+{
+  DBusWatch *watch;
+
+  watch = make_dbus_watch (skeleton, invocation, monitor);
+  watch->watch_id = meta_idle_monitor_add_idle_watch (monitor, interval,
+                                                      dbus_idle_callback,
+                                                      watch,
+                                                      destroy_dbus_watch);
+
+  meta_dbus_idle_monitor_complete_add_idle_watch (skeleton, invocation,
+                                                  watch->watch_id);
+
+  return TRUE;
+}
+
+static gboolean
+handle_add_user_active_watch (MetaDBusIdleMonitor   *skeleton,
+                              GDBusMethodInvocation *invocation,
+                              MetaIdleMonitor       *monitor)
+{
+  DBusWatch *watch;
+
+  watch = make_dbus_watch (skeleton, invocation, monitor);
+  watch->watch_id = meta_idle_monitor_add_user_active_watch (monitor,
+                                                             dbus_idle_callback,
+                                                             watch,
+                                                             destroy_dbus_watch);
+
+  meta_dbus_idle_monitor_complete_add_user_active_watch (skeleton, invocation,
+                                                         watch->watch_id);
+
+  return TRUE;
+}
+
+static gboolean
+handle_remove_watch (MetaDBusIdleMonitor   *skeleton,
+                     GDBusMethodInvocation *invocation,
+                     guint                  id,
+                     MetaIdleMonitor       *monitor)
+{
+  meta_idle_monitor_remove_watch (monitor, id);
+  meta_dbus_idle_monitor_complete_remove_watch (skeleton, invocation);
+
+  return TRUE;
+}
+
+static void
+create_monitor_skeleton (GDBusObjectManagerServer *server,
+                         MetaIdleMonitor          *monitor,
+                         const gchar              *path)
+{
+  MetaDBusIdleMonitor *skeleton;
+  MetaDBusObjectSkeleton *object;
+
+  skeleton = meta_dbus_idle_monitor_skeleton_new ();
+  g_signal_connect_object (skeleton, "handle-add-idle-watch",
+                           G_CALLBACK (handle_add_idle_watch), monitor, 0);
+  g_signal_connect_object (skeleton, "handle-add-user-active-watch",
+                           G_CALLBACK (handle_add_user_active_watch), monitor, 0);
+  g_signal_connect_object (skeleton, "handle-remove-watch",
+                           G_CALLBACK (handle_remove_watch), monitor, 0);
+  g_signal_connect_object (skeleton, "handle-get-idletime",
+                           G_CALLBACK (handle_get_idletime), monitor, 0);
+
+  object = meta_dbus_object_skeleton_new (path);
+  meta_dbus_object_skeleton_set_idle_monitor (object, skeleton);
+
+  g_dbus_object_manager_server_export (server, G_DBUS_OBJECT_SKELETON (object));
+
+  g_object_unref (skeleton);
+  g_object_unref (object);
+}
+
+static void
+on_device_added (GdkDeviceManager *device_manager,
+                 GdkDevice        *device,
+                 gpointer          user_data)
+{
+  FlashbackIdleMonitor *idle_monitor;
+  MetaIdleMonitor *monitor;
+  gint device_id;
+  gchar *path;
+
+  idle_monitor = FLASHBACK_IDLE_MONITOR (user_data);
+
+  device_id = gdk_x11_device_get_id (device);
+  monitor = meta_idle_monitor_get_for_device (device_id);
+  path = g_strdup_printf ("/org/gnome/Mutter/IdleMonitor/Device%d", device_id);
+
+  create_monitor_skeleton (idle_monitor->server, monitor, path);
+  g_free (path);
+}
+
+static void
+on_device_removed (GdkDeviceManager *device_manager,
+                   GdkDevice        *device,
+                   gpointer          user_data)
+{
+  FlashbackIdleMonitor *monitor;
+  gint device_id;
+  gchar *path;
+
+  monitor = FLASHBACK_IDLE_MONITOR (user_data);
+
+  device_id = gdk_x11_device_get_id (device);
+  path = g_strdup_printf ("/org/gnome/Mutter/IdleMonitor/Device%d", device_id);
+
+  g_dbus_object_manager_server_unexport (monitor->server, path);
+  g_free (path);
+}
+
+static void
+on_device_changed (GdkDeviceManager *device_manager,
+                   GdkDevice        *device,
+                   gpointer          user_data)
+{
+  FlashbackIdleMonitor *monitor;
+
+  monitor = FLASHBACK_IDLE_MONITOR (user_data);
+
+  if (gdk_device_get_device_type (device) == GDK_DEVICE_TYPE_FLOATING)
+    on_device_removed (device_manager, device, monitor);
+  else
+    on_device_added (device_manager, device, monitor);
+}
+
+static void
+on_bus_acquired (GDBusConnection *connection,
+                 const char      *name,
+                 gpointer         user_data)
+{
+  FlashbackIdleMonitor *idle_monitor;
+  const gchar *server_path;
+  MetaIdleMonitor *monitor;
+  const gchar *core_path;
+  GdkDisplay *display;
+  GdkDeviceManager *device_manager;
+  GList *master;
+  GList *slave;
+  GList *devices;
+  GList *iter;
+
+  idle_monitor = FLASHBACK_IDLE_MONITOR (user_data);
+
+  server_path = "/org/gnome/Mutter/IdleMonitor";
+  idle_monitor->server = g_dbus_object_manager_server_new (server_path);
+
+  monitor = meta_idle_monitor_get_core ();
+  core_path = "/org/gnome/Mutter/IdleMonitor/Core";
+  create_monitor_skeleton (idle_monitor->server, monitor, core_path);
+
+  display = gdk_display_get_default ();
+  device_manager = gdk_display_get_device_manager (display);
+  master = gdk_device_manager_list_devices (device_manager, GDK_DEVICE_TYPE_MASTER);
+  slave = gdk_device_manager_list_devices (device_manager, GDK_DEVICE_TYPE_SLAVE);
+  devices = g_list_concat (master, slave);
+
+  for (iter = devices; iter; iter = iter->next)
+    {
+      GdkDevice *device;
+
+      device = (GdkDevice *) iter->data;
+
+      on_device_added (device_manager, device, idle_monitor);
+    }
+
+  g_list_free (devices);
+
+  g_signal_connect_object (device_manager, "device-added",
+                           G_CALLBACK (on_device_added), idle_monitor, 0);
+  g_signal_connect_object (device_manager, "device-removed",
+                           G_CALLBACK (on_device_removed), idle_monitor, 0);
+  g_signal_connect_object (device_manager, "device-changed",
+                           G_CALLBACK (on_device_changed), idle_monitor, 0);
+
+  g_dbus_object_manager_server_set_connection (idle_monitor->server, connection);
+}
+
+static void
+on_name_acquired (GDBusConnection *connection,
+                  const char      *name,
+                  gpointer         user_data)
+{
+}
+
+static void
+on_name_lost (GDBusConnection *connection,
+              const char      *name,
+              gpointer         user_data)
+{
+}
+
+static GdkFilterReturn
+filter_func (GdkXEvent *xevent,
+             GdkEvent  *event,
+             gpointer   user_data)
+{
+  FlashbackIdleMonitor *monitor;
+  MetaBackend *backend;
+  XEvent *xev;
+  gint i;
+
+  monitor = FLASHBACK_IDLE_MONITOR (user_data);
+  backend = meta_get_backend ();
+  xev = (XEvent *) xevent;
+
+  if (xev->type == (monitor->xsync_event_base + XSyncAlarmNotify))
+    {
+      for (i = 0; i <= backend->device_id_max; i++)
+        {
+          if (backend->device_monitors[i])
+            meta_idle_monitor_xsync_handle_xevent (backend->device_monitors[i],
+                                                   (XSyncAlarmNotifyEvent*) xev);
+        }
+    }
+
+  return GDK_FILTER_CONTINUE;
+}
+
+static void
+flashback_idle_monitor_dispose (GObject *object)
+{
+  FlashbackIdleMonitor *monitor;
+  GdkDisplay *display;
+  GdkDeviceManager *device_manager;
+  GList *master;
+  GList *slave;
+  GList *devices;
+  GList *iter;
+  const gchar *core_path;
+
+  monitor = FLASHBACK_IDLE_MONITOR (object);
+
+  if (monitor->dbus_name_id > 0)
+    {
+      g_bus_unown_name (monitor->dbus_name_id);
+      monitor->dbus_name_id = 0;
+    }
+
+  display = gdk_display_get_default ();
+  device_manager = gdk_display_get_device_manager (display);
+  master = gdk_device_manager_list_devices (device_manager, GDK_DEVICE_TYPE_MASTER);
+  slave = gdk_device_manager_list_devices (device_manager, GDK_DEVICE_TYPE_SLAVE);
+  devices = g_list_concat (master, slave);
+
+  for (iter = devices; iter; iter = iter->next)
+    {
+      GdkDevice *device;
+
+      device = (GdkDevice *) iter->data;
+
+      on_device_removed (device_manager, device, monitor);
+    }
+
+  g_list_free (devices);
+
+  core_path = "/org/gnome/Mutter/IdleMonitor/Core";
+  g_dbus_object_manager_server_unexport (monitor->server, core_path);
+
+  g_clear_object (&monitor->server);
+
+  G_OBJECT_CLASS (flashback_idle_monitor_parent_class)->dispose (object);
+}
+
+static void
+flashback_idle_monitor_finalize (GObject *object)
+{
+  FlashbackIdleMonitor *monitor;
+
+  monitor = FLASHBACK_IDLE_MONITOR (object);
+
+  gdk_window_remove_filter (NULL, (GdkFilterFunc) filter_func, monitor);
+
+  G_OBJECT_CLASS (flashback_idle_monitor_parent_class)->finalize (object);
+}
+
+static void
+flashback_idle_monitor_init (FlashbackIdleMonitor *monitor)
+{
+  GdkDisplay *display;
+  Display *xdisplay;
+  gint event_base;
+  gint error_base;
+  gint major;
+  gint minor;
+
+  monitor->dbus_name_id = g_bus_own_name (G_BUS_TYPE_SESSION,
+                                          "org.gnome.Mutter.IdleMonitor",
+                                          G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT |
+                                          G_BUS_NAME_OWNER_FLAGS_REPLACE,
+                                          (GBusAcquiredCallback) on_bus_acquired,
+                                          (GBusNameAcquiredCallback) on_name_acquired,
+                                          (GBusNameLostCallback) on_name_lost,
+                                          monitor, NULL);
+
+  display = gdk_display_get_default ();
+  xdisplay = gdk_x11_display_get_xdisplay (display);
+
+  if (!XSyncQueryExtension (xdisplay, &event_base, &error_base))
+    g_critical ("Could not query XSync extension");
+
+  monitor->xsync_event_base = event_base;
+  monitor->xsync_error_base = error_base;
+
+  if (!XSyncInitialize (xdisplay, &major, &minor))
+    g_critical ("Could not initialize XSync");
+
+  gdk_window_add_filter (NULL, (GdkFilterFunc) filter_func, monitor);
+}
+
+static void
+flashback_idle_monitor_class_init (FlashbackIdleMonitorClass *monitor_class)
+{
+  GObjectClass *object_class;
+
+  object_class = G_OBJECT_CLASS (monitor_class);
+
+  object_class->dispose = flashback_idle_monitor_dispose;
+  object_class->finalize =flashback_idle_monitor_finalize;
+}
+
+FlashbackIdleMonitor *
+flashback_idle_monitor_new (void)
+{
+  return g_object_new (FLASHBACK_TYPE_IDLE_MONITOR, NULL);
+}
diff --git a/gnome-flashback/libidle-monitor/flashback-idle-monitor.h b/gnome-flashback/libidle-monitor/flashback-idle-monitor.h
new file mode 100644
index 0000000..6f72089
--- /dev/null
+++ b/gnome-flashback/libidle-monitor/flashback-idle-monitor.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Alberts Muktupāvels
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FLASHBACK_IDLE_MONITOR_H
+#define FLASHBACK_IDLE_MONITOR_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define FLASHBACK_TYPE_IDLE_MONITOR flashback_idle_monitor_get_type ()
+G_DECLARE_FINAL_TYPE (FlashbackIdleMonitor, flashback_idle_monitor,
+                      FLASHBACK, IDLE_MONITOR, GObject)
+
+FlashbackIdleMonitor *flashback_idle_monitor_new (void);
+
+G_END_DECLS
+
+#endif
diff --git a/gnome-flashback/libidle-monitor/meta-backend.c b/gnome-flashback/libidle-monitor/meta-backend.c
index d7ed2fd..3a0fced 100644
--- a/gnome-flashback/libidle-monitor/meta-backend.c
+++ b/gnome-flashback/libidle-monitor/meta-backend.c
@@ -24,8 +24,6 @@
 #include "meta-backend.h"
 #include "meta-idle-monitor-xsync.h"
 
-static MetaBackend *backend = NULL;
-
 G_DEFINE_TYPE (MetaBackend, meta_backend, G_TYPE_OBJECT);
 
 static void
@@ -143,6 +141,8 @@ meta_backend_init (MetaBackend *backend)
 MetaBackend *
 meta_get_backend (void)
 {
+  static MetaBackend *backend = NULL;
+
   if (!backend)
   	backend = g_object_new (META_TYPE_BACKEND, NULL);
 
diff --git a/gnome-flashback/libidle-monitor/meta-idle-monitor-dbus.c b/gnome-flashback/libidle-monitor/meta-idle-monitor-dbus.c
deleted file mode 100644
index 8a0cf9b..0000000
--- a/gnome-flashback/libidle-monitor/meta-idle-monitor-dbus.c
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright 2013 Red Hat, Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- *
- * Adapted from gnome-session/gnome-session/gs-idle-monitor.c and
- *         from gnome-desktop/libgnome-desktop/gnome-idle-monitor.c
- */
-
-#include "config.h"
-
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include <X11/extensions/sync.h>
-
-#include "meta-backend.h"
-#include "meta-idle-monitor.h"
-#include "meta-idle-monitor-dbus.h"
-#include "meta-dbus-idle-monitor.h"
-
-struct _MetaIdleMonitorDBusPrivate {
-	gint dbus_name_id;
-
-	int  xsync_event_base;
-	int  xsync_error_base;
-};
-
-G_DEFINE_TYPE_WITH_PRIVATE (MetaIdleMonitorDBus, meta_idle_monitor_dbus, G_TYPE_OBJECT);
-
-static gboolean
-handle_get_idletime (MetaDBusIdleMonitor   *skeleton,
-                     GDBusMethodInvocation *invocation,
-                     MetaIdleMonitor       *monitor)
-{
-  guint64 idletime;
-
-  idletime = meta_idle_monitor_get_idletime (monitor);
-  meta_dbus_idle_monitor_complete_get_idletime (skeleton, invocation, idletime);
-
-  return TRUE;
-}
-
-typedef struct {
-  MetaDBusIdleMonitor *dbus_monitor;
-  MetaIdleMonitor *monitor;
-  char *dbus_name;
-  guint watch_id;
-  guint name_watcher_id;
-} DBusWatch;
-
-static void
-destroy_dbus_watch (gpointer data)
-{
-  DBusWatch *watch = data;
-
-  g_object_unref (watch->dbus_monitor);
-  g_object_unref (watch->monitor);
-  g_free (watch->dbus_name);
-  g_bus_unwatch_name (watch->name_watcher_id);
-
-  g_slice_free (DBusWatch, watch);
-}
-
-static void
-dbus_idle_callback (MetaIdleMonitor *monitor,
-                    guint            watch_id,
-                    gpointer         user_data)
-{
-  DBusWatch *watch = user_data;
-  GDBusInterfaceSkeleton *skeleton = G_DBUS_INTERFACE_SKELETON (watch->dbus_monitor);
-
-  g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (skeleton),
-                                 watch->dbus_name,
-                                 g_dbus_interface_skeleton_get_object_path (skeleton),
-                                 "org.gnome.Mutter.IdleMonitor",
-                                 "WatchFired",
-                                 g_variant_new ("(u)", watch_id),
-                                 NULL);
-}
-
-static void
-name_vanished_callback (GDBusConnection *connection,
-                        const char      *name,
-                        gpointer         user_data)
-{
-  DBusWatch *watch = user_data;
-
-  meta_idle_monitor_remove_watch (watch->monitor, watch->watch_id);
-}
-
-static DBusWatch *
-make_dbus_watch (MetaDBusIdleMonitor   *skeleton,
-                 GDBusMethodInvocation *invocation,
-                 MetaIdleMonitor       *monitor)
-{
-  DBusWatch *watch;
-
-  watch = g_slice_new (DBusWatch);
-  watch->dbus_monitor = g_object_ref (skeleton);
-  watch->monitor = g_object_ref (monitor);
-  watch->dbus_name = g_strdup (g_dbus_method_invocation_get_sender (invocation));
-  watch->name_watcher_id = g_bus_watch_name_on_connection (g_dbus_method_invocation_get_connection (invocation),
-                                                           watch->dbus_name,
-                                                           G_BUS_NAME_WATCHER_FLAGS_NONE,
-                                                           NULL, /* appeared */
-                                                           name_vanished_callback,
-                                                           watch, NULL);
-
-  return watch;
-}
-
-static gboolean
-handle_add_idle_watch (MetaDBusIdleMonitor   *skeleton,
-                       GDBusMethodInvocation *invocation,
-                       guint64                interval,
-                       MetaIdleMonitor       *monitor)
-{
-  DBusWatch *watch;
-
-  watch = make_dbus_watch (skeleton, invocation, monitor);
-  watch->watch_id = meta_idle_monitor_add_idle_watch (monitor, interval,
-                                                      dbus_idle_callback, watch, destroy_dbus_watch);
-
-  meta_dbus_idle_monitor_complete_add_idle_watch (skeleton, invocation, watch->watch_id);
-
-  return TRUE;
-}
-
-static gboolean
-handle_add_user_active_watch (MetaDBusIdleMonitor   *skeleton,
-                              GDBusMethodInvocation *invocation,
-                              MetaIdleMonitor       *monitor)
-{
-
-  DBusWatch *watch;
-
-  watch = make_dbus_watch (skeleton, invocation, monitor);
-  watch->watch_id = meta_idle_monitor_add_user_active_watch (monitor,
-                                                             dbus_idle_callback, watch,
-                                                             destroy_dbus_watch);
-
-  meta_dbus_idle_monitor_complete_add_user_active_watch (skeleton, invocation, watch->watch_id);
-
-  return TRUE;
-}
-
-static gboolean
-handle_remove_watch (MetaDBusIdleMonitor   *skeleton,
-                     GDBusMethodInvocation *invocation,
-                     guint                  id,
-                     MetaIdleMonitor       *monitor)
-{
-  meta_idle_monitor_remove_watch (monitor, id);
-  meta_dbus_idle_monitor_complete_remove_watch (skeleton, invocation);
-
-  return TRUE;
-}
-
-static void
-create_monitor_skeleton (GDBusObjectManagerServer *manager,
-                         MetaIdleMonitor          *monitor,
-                         const char               *path)
-{
-  MetaDBusIdleMonitor *skeleton;
-  MetaDBusObjectSkeleton *object;
-
-  skeleton = meta_dbus_idle_monitor_skeleton_new ();
-  g_signal_connect_object (skeleton, "handle-add-idle-watch",
-                           G_CALLBACK (handle_add_idle_watch), monitor, 0);
-  g_signal_connect_object (skeleton, "handle-add-user-active-watch",
-                           G_CALLBACK (handle_add_user_active_watch), monitor, 0);
-  g_signal_connect_object (skeleton, "handle-remove-watch",
-                           G_CALLBACK (handle_remove_watch), monitor, 0);
-  g_signal_connect_object (skeleton, "handle-get-idletime",
-                           G_CALLBACK (handle_get_idletime), monitor, 0);
-
-  object = meta_dbus_object_skeleton_new (path);
-  meta_dbus_object_skeleton_set_idle_monitor (object, skeleton);
-
-  g_dbus_object_manager_server_export (manager, G_DBUS_OBJECT_SKELETON (object));
-
-  g_object_unref (skeleton);
-  g_object_unref (object);
-}
-
-static void
-on_device_added (GdkDeviceManager         *device_manager,
-                 GdkDevice                *device,
-                 GDBusObjectManagerServer *manager)
-{
-
-  MetaIdleMonitor *monitor;
-  gint device_id;
-  gchar *path;
-
-  device_id = gdk_x11_device_get_id (device);
-  monitor = meta_idle_monitor_get_for_device (device_id);
-  path = g_strdup_printf ("/org/gnome/Mutter/IdleMonitor/Device%d", device_id);
-
-  create_monitor_skeleton (manager, monitor, path);
-  g_free (path);
-}
-
-static void
-on_device_removed (GdkDeviceManager         *device_manager,
-                   GdkDevice                *device,
-                   GDBusObjectManagerServer *manager)
-{
-  gint device_id;
-  gchar *path;
-
-  device_id = gdk_x11_device_get_id (device);
-  path = g_strdup_printf ("/org/gnome/Mutter/IdleMonitor/Device%d", device_id);
-  g_dbus_object_manager_server_unexport (manager, path);
-  g_free (path);
-}
-
-static void
-on_device_changed (GdkDeviceManager         *device_manager,
-                   GdkDevice                *device,
-                   GDBusObjectManagerServer *manager)
-{
-	if (gdk_device_get_device_type (device) == GDK_DEVICE_TYPE_FLOATING)
-		on_device_removed (device_manager, device, manager);
-	else
-		on_device_added (device_manager, device, manager);
-}
-
-static void
-on_bus_acquired (GDBusConnection *connection,
-                 const char      *name,
-                 gpointer         user_data)
-{
-  GDBusObjectManagerServer *manager;
-  GdkDeviceManager *device_manager;
-  MetaIdleMonitor *monitor;
-  GList *devices, *iter;
-  char *path;
-
-  manager = g_dbus_object_manager_server_new ("/org/gnome/Mutter/IdleMonitor");
-
-  /* We never clear the core monitor, as that's supposed to cumulate idle times from
-     all devices */
-  monitor = meta_idle_monitor_get_core ();
-  path = g_strdup ("/org/gnome/Mutter/IdleMonitor/Core");
-  create_monitor_skeleton (manager, monitor, path);
-  g_free (path);
-
-  device_manager = gdk_display_get_device_manager (gdk_display_get_default ());
-  devices = gdk_device_manager_list_devices (device_manager, GDK_DEVICE_TYPE_MASTER);
-  devices = g_list_concat (devices, gdk_device_manager_list_devices (device_manager, GDK_DEVICE_TYPE_SLAVE));
-
-  for (iter = devices; iter; iter = iter->next)
-    on_device_added (device_manager, iter->data, manager);
-
-  g_list_free (devices);
-
-  g_signal_connect_object (device_manager, "device-added",
-                           G_CALLBACK (on_device_added), manager, 0);
-  g_signal_connect_object (device_manager, "device-removed",
-                           G_CALLBACK (on_device_removed), manager, 0);
-  g_signal_connect_object (device_manager, "device-changed",
-                           G_CALLBACK (on_device_changed), manager, 0);
-
-  g_dbus_object_manager_server_set_connection (manager, connection);
-}
-
-static void
-on_name_acquired (GDBusConnection *connection,
-                  const char      *name,
-                  gpointer         user_data)
-{
-}
-
-static void
-on_name_lost (GDBusConnection *connection,
-              const char      *name,
-              gpointer         user_data)
-{
-}
-
-static GdkFilterReturn
-filter_func (GdkXEvent *xevent,
-             GdkEvent  *event,
-             gpointer   user_data)
-{
-	MetaIdleMonitorDBus *monitor = META_IDLE_MONITOR_DBUS (user_data);
-	MetaBackend *backend = meta_get_backend ();
-	XEvent *xev = (XEvent *) xevent;
-	int i;
-
-	if (xev->type == (monitor->priv->xsync_event_base + XSyncAlarmNotify)) {
-		for (i = 0; i <= backend->device_id_max; i++) {
-			if (backend->device_monitors[i]) {
-				meta_idle_monitor_xsync_handle_xevent (backend->device_monitors[i], (XSyncAlarmNotifyEvent*) xev);
-			}
-		}
-	}
-
-	return GDK_FILTER_CONTINUE;
-}
-
-static void
-meta_idle_monitor_dbus_dispose (GObject *object)
-{
-	MetaIdleMonitorDBus *monitor = META_IDLE_MONITOR_DBUS (object);
-
-	if (monitor->priv->dbus_name_id) {
-		g_bus_unown_name (monitor->priv->dbus_name_id);
-		monitor->priv->dbus_name_id = 0;
-	}
-
-	G_OBJECT_CLASS (meta_idle_monitor_dbus_parent_class)->dispose (object);
-}
-
-static void
-meta_idle_monitor_dbus_finalize (GObject *object)
-{
-	MetaIdleMonitorDBus *monitor = META_IDLE_MONITOR_DBUS (object);
-
-	gdk_window_remove_filter (NULL, filter_func, monitor);
-
-	G_OBJECT_CLASS (meta_idle_monitor_dbus_parent_class)->finalize (object);
-}
-
-static void
-meta_idle_monitor_dbus_init (MetaIdleMonitorDBus *monitor)
-{
-	GdkDisplay *display;
-	Display *xdisplay;
-	int major, minor;
-
-    monitor->priv = meta_idle_monitor_dbus_get_instance_private (monitor);
-	monitor->priv->dbus_name_id = g_bus_own_name (G_BUS_TYPE_SESSION,
-	                                              "org.gnome.Mutter.IdleMonitor",
-	                                              G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT |
-	                                              G_BUS_NAME_OWNER_FLAGS_REPLACE,
-	                                              on_bus_acquired,
-	                                              on_name_acquired,
-	                                              on_name_lost,
-	                                              NULL, NULL);
-
-	display = gdk_display_get_default ();
-	xdisplay = gdk_x11_display_get_xdisplay (display);
-
-	if (!XSyncQueryExtension (xdisplay, &monitor->priv->xsync_event_base, &monitor->priv->xsync_error_base))
-    	g_critical ("Could not query XSync extension");
-
-	if (!XSyncInitialize (xdisplay, &major, &minor))
-    	g_critical ("Could not initialize XSync");
-
-	gdk_window_add_filter (NULL, filter_func, monitor);
-}
-
-static void
-meta_idle_monitor_dbus_class_init (MetaIdleMonitorDBusClass *class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (class);
-
-	object_class->dispose = meta_idle_monitor_dbus_dispose;
-	object_class->finalize = meta_idle_monitor_dbus_finalize;
-}
-
-MetaIdleMonitorDBus *
-meta_idle_monitor_dbus_new (void)
-{
-	return g_object_new (META_TYPE_IDLE_MONITOR_DBUS, NULL);
-}
diff --git a/gnome-flashback/libidle-monitor/meta-idle-monitor-dbus.h b/gnome-flashback/libidle-monitor/meta-idle-monitor-dbus.h
deleted file mode 100644
index 1957dcd..0000000
--- a/gnome-flashback/libidle-monitor/meta-idle-monitor-dbus.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2013 Red Hat, Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- *
- * Adapted from gnome-session/gnome-session/gs-idle-monitor.c and
- *         from gnome-desktop/libgnome-desktop/gnome-idle-monitor.c
- */
-
-#ifndef META_IDLE_MONITOR_DBUS_H
-#define META_IDLE_MONITOR_DBUS_H
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define META_TYPE_IDLE_MONITOR_DBUS         (meta_idle_monitor_dbus_get_type ())
-#define META_IDLE_MONITOR_DBUS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), META_TYPE_IDLE_MONITOR_DBUS, MetaIdleMonitorDBus))
-#define META_IDLE_MONITOR_DBUS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST ((k),    META_TYPE_IDLE_MONITOR_DBUS, MetaIdleMonitorDBusClass))
-#define META_IS_IDLE_MONITOR_DBUS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), META_TYPE_IDLE_MONITOR_DBUS))
-#define META_IS_IDLE_MONITOR_DBUS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k),    META_TYPE_IDLE_MONITOR_DBUS))
-#define META_IDLE_MONITOR_DBUS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o),  META_TYPE_IDLE_MONITOR_DBUS, MetaIdleMonitorDBusClass))
-
-typedef struct _MetaIdleMonitorDBus        MetaIdleMonitorDBus;
-typedef struct _MetaIdleMonitorDBusClass   MetaIdleMonitorDBusClass;
-typedef struct _MetaIdleMonitorDBusPrivate MetaIdleMonitorDBusPrivate;
-
-struct _MetaIdleMonitorDBus {
-	GObject                     parent;
-	MetaIdleMonitorDBusPrivate *priv;
-};
-
-struct _MetaIdleMonitorDBusClass {
-    GObjectClass parent_class;
-};
-
-GType                meta_idle_monitor_dbus_get_type (void);
-MetaIdleMonitorDBus *meta_idle_monitor_dbus_new      (void);
-
-G_END_DECLS
-
-#endif
diff --git a/gnome-flashback/libidle-monitor/meta-idle-monitor.c b/gnome-flashback/libidle-monitor/meta-idle-monitor.c
index c323bdc..203940f 100644
--- a/gnome-flashback/libidle-monitor/meta-idle-monitor.c
+++ b/gnome-flashback/libidle-monitor/meta-idle-monitor.c
@@ -30,7 +30,6 @@
 
 #include "meta-idle-monitor.h"
 #include "meta-idle-monitor-xsync.h"
-#include "meta-idle-monitor-dbus.h"
 #include "meta-backend.h"
 
 G_STATIC_ASSERT(sizeof(unsigned long) == sizeof(gpointer));
@@ -149,8 +148,6 @@ meta_idle_monitor_init (MetaIdleMonitor *monitor)
 {
 }
 
-static MetaIdleMonitor *device_monitors[256];
-
 /**
  * meta_idle_monitor_get_core:
  *
diff --git a/gnome-flashback/libscreencast/Makefile.am b/gnome-flashback/libscreencast/Makefile.am
index 836cc1f..e871c34 100644
--- a/gnome-flashback/libscreencast/Makefile.am
+++ b/gnome-flashback/libscreencast/Makefile.am
@@ -1,18 +1,31 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libscreencast.la
+	libscreencast.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libscreencast_la_CFLAGS = \
 	$(SCREENCAST_CFLAGS) \
-	-I$(top_builddir)/gnome-flashback/libscreencast
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
+	-I$(top_builddir)/gnome-flashback/libscreencast \
+	$(NULL)
 
 libscreencast_la_SOURCES = \
 	flashback-dbus-screencast.c \
 	flashback-dbus-screencast.h \
 	flashback-screencast.c \
-	flashback-screencast.h
+	flashback-screencast.h \
+	$(NULL)
+
+libscreencast_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libscreencast_la_LIBADD = \
-	$(SCREENCAST_LIBS)
+	$(SCREENCAST_LIBS) \
+	$(NULL)
 
 flashback-dbus-screencast.h:
 flashback-dbus-screencast.c: org.gnome.Shell.Screencast.xml
@@ -26,12 +39,15 @@ flashback-dbus-screencast.c: org.gnome.Shell.Screencast.xml
 
 BUILT_SOURCES = \
 	flashback-dbus-screencast.c \
-	flashback-dbus-screencast.h
+	flashback-dbus-screencast.h \
+	$(NULL)
 
 EXTRA_DIST = \
-	org.gnome.Shell.Screencast.xml
+	org.gnome.Shell.Screencast.xml \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libscreenshot/Makefile.am b/gnome-flashback/libscreenshot/Makefile.am
index 5eb38ca..1fa9bec 100644
--- a/gnome-flashback/libscreenshot/Makefile.am
+++ b/gnome-flashback/libscreenshot/Makefile.am
@@ -1,18 +1,31 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libscreenshot.la
+	libscreenshot.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libscreenshot_la_CFLAGS = \
 	$(SCREENSHOT_CFLAGS) \
-	-I$(top_builddir)/gnome-flashback/libscreenshot
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
+	-I$(top_builddir)/gnome-flashback/libscreenshot \
+	$(NULL)
 
 libscreenshot_la_SOURCES = \
 	flashback-dbus-screenshot.c \
 	flashback-dbus-screenshot.h \
 	flashback-screenshot.c \
-	flashback-screenshot.h
+	flashback-screenshot.h \
+	$(NULL)
+
+libscreenshot_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libscreenshot_la_LIBADD = \
-	$(SCREENSHOT_LIBS)
+	$(SCREENSHOT_LIBS) \
+	$(NULL)
 
 flashback-dbus-screenshot.h:
 flashback-dbus-screenshot.c: org.gnome.Shell.Screenshot.xml
@@ -26,12 +39,15 @@ flashback-dbus-screenshot.c: org.gnome.Shell.Screenshot.xml
 
 BUILT_SOURCES = \
 	flashback-dbus-screenshot.c \
-	flashback-dbus-screenshot.h
+	flashback-dbus-screenshot.h \
+	$(NULL)
 
 EXTRA_DIST = \
-	org.gnome.Shell.Screenshot.xml
+	org.gnome.Shell.Screenshot.xml \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libshell/Makefile.am b/gnome-flashback/libshell/Makefile.am
index 03e9061..bbc9cca 100644
--- a/gnome-flashback/libshell/Makefile.am
+++ b/gnome-flashback/libshell/Makefile.am
@@ -1,11 +1,17 @@
+NULL =
+
 noinst_LTLIBRARIES = \
-	libshell.la
+	libshell.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libshell_la_CFLAGS = \
 	$(SHELL_CFLAGS) \
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
 	-I$(srcdir)/../../gnome-flashback \
 	-I$(top_builddir)/gnome-flashback \
-	-I$(top_builddir)/gnome-flashback/libshell
+	-I$(top_builddir)/gnome-flashback/libshell \
+	$(NULL)
 
 libshell_la_SOURCES = \
 	flashback-dbus-shell.c \
@@ -21,10 +27,17 @@ libshell_la_SOURCES = \
 	flashback-osd-window.c \
 	flashback-osd-window.h \
 	flashback-shell.c \
-	flashback-shell.h
+	flashback-shell.h \
+	$(NULL)
+
+libshell_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libshell_la_LIBADD = \
-	$(SHELL_LIBS)
+	$(SHELL_LIBS) \
+	$(NULL)
 
 flashback-dbus-shell.h:
 flashback-dbus-shell.c: org.gnome.Shell.xml
@@ -36,12 +49,15 @@ flashback-dbus-shell.c: org.gnome.Shell.xml
 
 BUILT_SOURCES = \
 	flashback-dbus-shell.c \
-	flashback-dbus-shell.h
+	flashback-dbus-shell.h \
+	$(NULL)
 
 EXTRA_DIST = \
-	org.gnome.Shell.xml
+	org.gnome.Shell.xml \
+	$(NULL)
 
 CLEANFILES = \
-	$(BUILT_SOURCES)
+	$(BUILT_SOURCES) \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libshell/flashback-key-bindings.c b/gnome-flashback/libshell/flashback-key-bindings.c
index f14fd4e..a2c497a 100644
--- a/gnome-flashback/libshell/flashback-key-bindings.c
+++ b/gnome-flashback/libshell/flashback-key-bindings.c
@@ -15,11 +15,13 @@
  * along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <config.h>
+#include "config.h"
+
 #include <gtk/gtk.h>
 #include <gtk/gtkx.h>
 
 #include <X11/Xlib.h>
+#include <X11/XKBlib.h>
 
 #include "flashback-key-bindings.h"
 
@@ -55,33 +57,44 @@ static guint ScrollLockMask = 0;
 
 G_DEFINE_TYPE_WITH_PRIVATE (FlashbackKeyBindings, flashback_key_bindings, G_TYPE_OBJECT)
 
-static guint
-get_real_modifiers (GdkModifierType modifiers)
+static gboolean
+devirtualize_modifiers (GdkModifierType  modifiers,
+                        GdkModifierType  gdk_mask,
+                        unsigned int     real_mask,
+                        unsigned int    *mask)
+{
+  if (modifiers & gdk_mask)
+    {
+      if (real_mask == 0)
+        return FALSE;
+
+       *mask |= real_mask;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+get_real_modifiers (GdkModifierType  modifiers,
+                    guint           *mask)
 {
-	guint mods = 0;
-
-	if (modifiers & GDK_SHIFT_MASK)
-		mods |= ShiftMask;
-	if (modifiers & GDK_CONTROL_MASK)
-		mods |= ControlMask;
-	if (modifiers & GDK_MOD1_MASK)
-		mods |= Mod1Mask;
-	if (modifiers & GDK_META_MASK)
-		mods |= MetaMask;
-	if (modifiers & GDK_HYPER_MASK)
-		mods |= HyperMask;
-	if (modifiers & GDK_SUPER_MASK)
-		mods |= SuperMask;
-	if (modifiers & GDK_MOD2_MASK)
-		mods |= Mod2Mask;
-	if (modifiers & GDK_MOD3_MASK)
-		mods |= Mod3Mask;
-	if (modifiers & GDK_MOD4_MASK)
-		mods |= Mod4Mask;
-	if (modifiers & GDK_MOD5_MASK)
-		mods |= Mod5Mask;
-
-	return mods;
+	gboolean devirtualized;
+
+	devirtualized = TRUE;
+	*mask = 0;
+
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_SHIFT_MASK, ShiftMask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_CONTROL_MASK, ControlMask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_MOD1_MASK, Mod1Mask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_META_MASK, MetaMask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_HYPER_MASK, HyperMask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_SUPER_MASK, SuperMask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_MOD2_MASK, Mod2Mask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_MOD3_MASK, Mod3Mask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_MOD4_MASK, Mod4Mask, mask);
+	devirtualized &= devirtualize_modifiers (modifiers, GDK_MOD5_MASK, Mod5Mask, mask);
+
+	return devirtualized;
 }
 
 static GVariant *
@@ -155,9 +168,6 @@ flashback_key_bindings_change_keygrab (FlashbackKeyBindings *bindings,
 {
 	guint ignored_mask;
 
-	if (modifiers == 0)
-		return;
-
 	gdk_error_trap_push ();
 
 	ignored_mask = 0;
@@ -267,7 +277,7 @@ flashback_key_bindings_grab (FlashbackKeyBindings *bindings,
 	GdkModifierType modifiers;
 	guint real_modifiers;
 	guint keycode;
-	static next_action = 0;
+	static guint next_action = 0;
 
 	gtk_accelerator_parse (accelerator, &keyval, &modifiers);
 	if (!gtk_accelerator_valid (keyval, modifiers)) {
@@ -281,7 +291,8 @@ flashback_key_bindings_grab (FlashbackKeyBindings *bindings,
 	if (keycode == 0)
 		return 0;
 
-	real_modifiers = get_real_modifiers (modifiers);
+	if (!get_real_modifiers (modifiers, &real_modifiers))
+		return 0;
 
 	flashback_key_bindings_change_keygrab (bindings,
 	                                       TRUE,
diff --git a/gnome-flashback/libsound-applet/Makefile.am b/gnome-flashback/libsound-applet/Makefile.am
index 6d58810..23627d3 100644
--- a/gnome-flashback/libsound-applet/Makefile.am
+++ b/gnome-flashback/libsound-applet/Makefile.am
@@ -1,13 +1,20 @@
+NULL =
+
 SUBDIRS = \
-	gvc
+	gvc \
+	$(NULL)
 
 noinst_LTLIBRARIES = \
-	libsound-applet.la
+	libsound-applet.la \
+	$(NULL)
 
-AM_CPPFLAGS = \
+libsound_applet_la_CFLAGS = \
 	$(SOUND_APPLET_CFLAGS) \
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
 	-I$(top_builddir)/gnome-flashback/libsound-applet \
-	-I$(srcdir)/gvc
+	-I$(srcdir)/gvc \
+	$(NULL)
 
 libsound_applet_la_SOURCES = \
 	gvc-applet.c \
@@ -15,11 +22,18 @@ libsound_applet_la_SOURCES = \
 	gvc-channel-bar.c \
 	gvc-channel-bar.h \
 	gvc-stream-status-icon.c \
-	gvc-stream-status-icon.h
+	gvc-stream-status-icon.h \
+	$(NULL)
+
+libsound_applet_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
 
 libsound_applet_la_LIBADD = \
 	-lm \
 	$(SOUND_APPLET_LIBS) \
-	gvc/libgvc.la
+	gvc/libgvc.la \
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libsound-applet/gvc-applet.c b/gnome-flashback/libsound-applet/gvc-applet.c
index 41fff13..7c38a4b 100644
--- a/gnome-flashback/libsound-applet/gvc-applet.c
+++ b/gnome-flashback/libsound-applet/gvc-applet.c
@@ -60,8 +60,6 @@ struct GvcAppletPrivate
         GvcMixerControl     *control;
 };
 
-static void     gvc_applet_class_init (GvcAppletClass *klass);
-static void     gvc_applet_init       (GvcApplet      *applet);
 static void     gvc_applet_finalize   (GObject        *object);
 
 G_DEFINE_TYPE (GvcApplet, gvc_applet, G_TYPE_OBJECT)
@@ -78,8 +76,10 @@ maybe_show_status_icons (GvcApplet *applet)
         if (stream == NULL) {
                 show = FALSE;
         }
-        gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->output_status_icon), show);
 
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+        gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->output_status_icon), show);
+        G_GNUC_END_IGNORE_DEPRECATIONS
 
         show = FALSE;
         stream = gvc_mixer_control_get_default_source (applet->priv->control);
@@ -104,7 +104,10 @@ maybe_show_status_icons (GvcApplet *applet)
                         }
                 }
         }
+
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->input_status_icon), show);
+        G_GNUC_END_IGNORE_DEPRECATIONS
 
         g_slist_free (source_outputs);
 }
@@ -265,14 +268,21 @@ gvc_applet_init (GvcApplet *applet)
                                                                        output_icon_names);
         gvc_stream_status_icon_set_display_name (applet->priv->output_status_icon,
                                                  _("Output"));
+
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         gtk_status_icon_set_title (GTK_STATUS_ICON (applet->priv->output_status_icon),
                                    _("Sound Output Volume"));
+        G_GNUC_END_IGNORE_DEPRECATIONS
+
         applet->priv->input_status_icon = gvc_stream_status_icon_new (NULL,
                                                                       input_icon_names);
         gvc_stream_status_icon_set_display_name (applet->priv->input_status_icon,
                                                  _("Input"));
+
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         gtk_status_icon_set_title (GTK_STATUS_ICON (applet->priv->input_status_icon),
                                    _("Microphone Volume"));
+        G_GNUC_END_IGNORE_DEPRECATIONS
 }
 
 static void
diff --git a/gnome-flashback/libsound-applet/gvc-channel-bar.c b/gnome-flashback/libsound-applet/gvc-channel-bar.c
index 26cafae..f11f5bc 100644
--- a/gnome-flashback/libsound-applet/gvc-channel-bar.c
+++ b/gnome-flashback/libsound-applet/gvc-channel-bar.c
@@ -50,11 +50,8 @@ struct GvcChannelBarPrivate
         GtkWidget     *low_image;
         GtkWidget     *scale;
         GtkWidget     *high_image;
-        GtkWidget     *mute_box;
-        GtkWidget     *mute_switch;
         GtkAdjustment *adjustment;
         GtkAdjustment *zero_adjustment;
-        gboolean       show_mute;
         gboolean       is_muted;
         char          *icon_name;
         char          *low_icon_name;
@@ -70,7 +67,6 @@ enum
 {
         PROP_0,
         PROP_ORIENTATION,
-        PROP_SHOW_MUTE,
         PROP_IS_MUTED,
         PROP_ADJUSTMENT,
         PROP_ICON_NAME,
@@ -79,8 +75,6 @@ enum
         PROP_IS_AMPLIFIED
 };
 
-static void     gvc_channel_bar_class_init    (GvcChannelBarClass *klass);
-static void     gvc_channel_bar_init          (GvcChannelBar      *channel_bar);
 static void     gvc_channel_bar_finalize      (GObject            *object);
 
 static gboolean on_scale_button_press_event   (GtkWidget      *widget,
@@ -126,8 +120,6 @@ _scale_box_new (GvcChannelBar *bar)
 
                 gtk_box_pack_start (GTK_BOX (ebox), priv->low_image, FALSE, FALSE, 0);
                 gtk_widget_hide (priv->low_image);
-
-                gtk_box_pack_start (GTK_BOX (ebox), priv->mute_box, FALSE, FALSE, 0);
         } else {
                 bar->priv->scale_box = box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
 
@@ -150,8 +142,6 @@ _scale_box_new (GvcChannelBar *bar)
 
                 gtk_box_pack_start (GTK_BOX (ebox), priv->high_image, FALSE, FALSE, 0);
                 gtk_widget_show (priv->high_image);
-
-                gtk_box_pack_start (GTK_BOX (ebox), priv->mute_box, FALSE, FALSE, 0);
         }
 
         ca_gtk_widget_disable_sounds (bar->priv->scale, FALSE);
@@ -205,12 +195,10 @@ update_layout (GvcChannelBar *bar)
         frame = gtk_widget_get_parent (box);
 
         g_object_ref (bar->priv->image);
-        g_object_ref (bar->priv->mute_box);
         g_object_ref (bar->priv->low_image);
         g_object_ref (bar->priv->high_image);
 
         gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->image);
-        gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->mute_box);
 
         if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
                 gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->low_image);
@@ -229,7 +217,6 @@ update_layout (GvcChannelBar *bar)
         gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
 
         g_object_unref (bar->priv->image);
-        g_object_unref (bar->priv->mute_box);
         g_object_unref (bar->priv->low_image);
         g_object_unref (bar->priv->high_image);
 
@@ -424,8 +411,9 @@ gvc_channel_bar_scroll (GvcChannelBar *bar, GdkEventScroll *event)
 		case GDK_SCROLL_RIGHT:
 			dy = -1.0;
 			break;
+		case GDK_SCROLL_SMOOTH:
 		default:
-			;
+			break;
 		}
 	}
 
@@ -478,24 +466,15 @@ on_zero_adjustment_value_changed (GtkAdjustment *adjustment,
         value = gtk_adjustment_get_value (bar->priv->zero_adjustment);
         gtk_adjustment_set_value (bar->priv->adjustment, value);
 
-
-        if (bar->priv->show_mute == FALSE) {
-                /* this means the adjustment moved away from zero and
-                 * therefore we should unmute and set the volume. */
-                gvc_channel_bar_set_is_muted (bar, value > 0.0);
-        }
+        /* this means the adjustment moved away from zero and
+         * therefore we should unmute and set the volume. */
+        gvc_channel_bar_set_is_muted (bar, value > 0.0);
 }
 
 static void
 update_mute_switch (GvcChannelBar *bar)
 {
-        if (bar->priv->show_mute) {
-                gtk_widget_show (bar->priv->mute_switch);
-                gtk_switch_set_active (GTK_SWITCH (bar->priv->mute_switch),
-                                       !bar->priv->is_muted);
-        } else {
-                gtk_widget_hide (bar->priv->mute_switch);
-        }
+
 
         if (bar->priv->is_muted) {
                 /* If we aren't showing the mute button then
@@ -515,7 +494,6 @@ update_mute_switch (GvcChannelBar *bar)
                  * and tell the front-end that the value changed */
                 gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale),
                                           bar->priv->adjustment);
-                gtk_adjustment_value_changed (bar->priv->adjustment);
         }
 }
 
@@ -542,26 +520,6 @@ gvc_channel_bar_get_is_muted  (GvcChannelBar *bar)
 }
 
 void
-gvc_channel_bar_set_show_mute (GvcChannelBar *bar,
-                               gboolean       show_mute)
-{
-        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
-
-        if (show_mute != bar->priv->show_mute) {
-                bar->priv->show_mute = show_mute;
-                g_object_notify (G_OBJECT (bar), "show-mute");
-                update_mute_switch (bar);
-        }
-}
-
-gboolean
-gvc_channel_bar_get_show_mute (GvcChannelBar *bar)
-{
-        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
-        return bar->priv->show_mute;
-}
-
-void
 gvc_channel_bar_set_is_amplified (GvcChannelBar *bar, gboolean amplified)
 {
         g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
@@ -591,13 +549,6 @@ gvc_channel_bar_set_is_amplified (GvcChannelBar *bar, gboolean amplified)
                 }
 
                 g_free (str);
-                gtk_alignment_set (GTK_ALIGNMENT (bar->priv->mute_box), 0.5, 0, 0, 0);
-                gtk_misc_set_alignment (GTK_MISC (bar->priv->low_image), 0.5, 0.15);
-                gtk_misc_set_alignment (GTK_MISC (bar->priv->high_image), 0.5, 0.15);
-        } else {
-                gtk_alignment_set (GTK_ALIGNMENT (bar->priv->mute_box), 0.5, 0.5, 0, 0);
-                gtk_misc_set_alignment (GTK_MISC (bar->priv->low_image), 0.5, 0.5);
-                gtk_misc_set_alignment (GTK_MISC (bar->priv->high_image), 0.5, 0.5);
         }
 }
 
@@ -631,9 +582,6 @@ gvc_channel_bar_set_property (GObject       *object,
         case PROP_IS_MUTED:
                 gvc_channel_bar_set_is_muted (self, g_value_get_boolean (value));
                 break;
-        case PROP_SHOW_MUTE:
-                gvc_channel_bar_set_show_mute (self, g_value_get_boolean (value));
-                break;
         case PROP_ICON_NAME:
                 gvc_channel_bar_set_icon_name (self, g_value_get_string (value));
                 break;
@@ -671,9 +619,6 @@ gvc_channel_bar_get_property (GObject     *object,
         case PROP_IS_MUTED:
                 g_value_set_boolean (value, priv->is_muted);
                 break;
-        case PROP_SHOW_MUTE:
-                g_value_set_boolean (value, priv->show_mute);
-                break;
         case PROP_ICON_NAME:
                 g_value_set_string (value, priv->icon_name);
                 break;
@@ -737,13 +682,6 @@ gvc_channel_bar_class_init (GvcChannelBarClass *klass)
                                                                "Whether stream is muted",
                                                                FALSE,
                                                                G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_SHOW_MUTE,
-                                         g_param_spec_boolean ("show-mute",
-                                                               "show mute",
-                                                               "Whether stream is muted",
-                                                               FALSE,
-                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
 
         g_object_class_install_property (object_class,
                                          PROP_ADJUSTMENT,
@@ -785,16 +723,6 @@ gvc_channel_bar_class_init (GvcChannelBarClass *klass)
 }
 
 static void
-on_mute_switch_toggled (GtkSwitch     *sw,
-                        GParamSpec *pspec,
-                        GvcChannelBar *bar)
-{
-        gboolean is_muted;
-        is_muted = gtk_switch_get_active (sw);
-        gvc_channel_bar_set_is_muted (bar, !is_muted);
-}
-
-static void
 gvc_channel_bar_init (GvcChannelBar *bar)
 {
         GtkWidget *frame;
@@ -827,15 +755,6 @@ gvc_channel_bar_init (GvcChannelBar *bar)
                           G_CALLBACK (on_zero_adjustment_value_changed),
                           bar);
 
-        bar->priv->mute_switch = gtk_switch_new ();
-        gtk_widget_set_no_show_all (bar->priv->mute_switch, TRUE);
-        g_signal_connect (bar->priv->mute_switch,
-                          "notify::active",
-                          G_CALLBACK (on_mute_switch_toggled),
-                          bar);
-        bar->priv->mute_box = gtk_alignment_new (0.5, 0.5, 0, 0);
-        gtk_container_add (GTK_CONTAINER (bar->priv->mute_box), bar->priv->mute_switch);
-
         bar->priv->low_image = gtk_image_new_from_icon_name ("audio-volume-low",
                                                              GTK_ICON_SIZE_MENU);
         gtk_style_context_add_class (gtk_widget_get_style_context (bar->priv->low_image), "dim-label");
diff --git a/gnome-flashback/libsound-applet/gvc-channel-bar.h b/gnome-flashback/libsound-applet/gvc-channel-bar.h
index 8b72060..9c88e3e 100644
--- a/gnome-flashback/libsound-applet/gvc-channel-bar.h
+++ b/gnome-flashback/libsound-applet/gvc-channel-bar.h
@@ -62,9 +62,6 @@ GtkAdjustment *     gvc_channel_bar_get_adjustment      (GvcChannelBar *bar);
 gboolean            gvc_channel_bar_get_is_muted        (GvcChannelBar *bar);
 void                gvc_channel_bar_set_is_muted        (GvcChannelBar *bar,
                                                          gboolean       is_muted);
-gboolean            gvc_channel_bar_get_show_mute       (GvcChannelBar *bar);
-void                gvc_channel_bar_set_show_mute       (GvcChannelBar *bar,
-                                                         gboolean       show_mute);
 void                gvc_channel_bar_set_size_group      (GvcChannelBar *bar,
                                                          GtkSizeGroup  *group,
                                                          gboolean       symmetric);
diff --git a/gnome-flashback/libsound-applet/gvc-stream-status-icon.c b/gnome-flashback/libsound-applet/gvc-stream-status-icon.c
index 8623845..d8161d6 100644
--- a/gnome-flashback/libsound-applet/gvc-stream-status-icon.c
+++ b/gnome-flashback/libsound-applet/gvc-stream-status-icon.c
@@ -55,8 +55,6 @@ enum
         PROP_ICON_NAMES,
 };
 
-static void     gvc_stream_status_icon_class_init (GvcStreamStatusIconClass *klass);
-static void     gvc_stream_status_icon_init       (GvcStreamStatusIcon      *stream_status_icon);
 static void     gvc_stream_status_icon_finalize   (GObject                  *object);
 
 G_DEFINE_TYPE (GvcStreamStatusIcon, gvc_stream_status_icon, GTK_TYPE_STATUS_ICON)
@@ -138,11 +136,14 @@ popup_dock (GvcStreamStatusIcon *icon,
 
         update_dock (icon);
 
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         screen = gtk_status_icon_get_screen (GTK_STATUS_ICON (icon));
         res = gtk_status_icon_get_geometry (GTK_STATUS_ICON (icon),
                                             &screen,
                                             &area,
                                             &orientation);
+        G_GNUC_END_IGNORE_DEPRECATIONS
+
         if (! res) {
                 g_warning ("Unable to determine geometry of status icon");
                 return FALSE;
@@ -210,7 +211,7 @@ popup_dock (GvcStreamStatusIcon *icon,
                                      GDK_OWNERSHIP_NONE, TRUE,
                                      GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
                                      GDK_POINTER_MOTION_MASK | GDK_SCROLL_MASK,
-                                     NULL, time) != GDK_GRAB_SUCCESS) {
+                                     NULL, time) == GDK_GRAB_SUCCESS) {
                         icon->priv->grabbed_pointer = g_object_ref (device);
                         grabbed = TRUE;
                         break;
@@ -218,7 +219,7 @@ popup_dock (GvcStreamStatusIcon *icon,
         }
         g_list_free (list);
 
-        if (grabbed) {
+        if (grabbed == FALSE) {
                 ungrab (icon, time);
                 return FALSE;
         }
@@ -232,7 +233,7 @@ popup_dock (GvcStreamStatusIcon *icon,
                 if (gdk_device_grab (device, window,
                                      GDK_OWNERSHIP_NONE, TRUE,
                                      GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK,
-                                     NULL, time) != GDK_GRAB_SUCCESS) {
+                                     NULL, time) == GDK_GRAB_SUCCESS) {
                         icon->priv->grabbed_keyboard = g_object_ref (device);
                         grabbed = TRUE;
                         break;
@@ -240,7 +241,7 @@ popup_dock (GvcStreamStatusIcon *icon,
         }
         g_list_free (list);
 
-        if (grabbed) {
+        if (grabbed == FALSE) {
                 ungrab (icon, time);
                 return FALSE;
         }
@@ -331,6 +332,8 @@ on_status_icon_popup_menu (GtkStatusIcon       *status_icon,
         gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 
         gtk_widget_show_all (menu);
+
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         gtk_menu_popup (GTK_MENU (menu),
                         NULL,
                         NULL,
@@ -338,6 +341,7 @@ on_status_icon_popup_menu (GtkStatusIcon       *status_icon,
                         status_icon,
                         button,
                         activate_time);
+        G_GNUC_END_IGNORE_DEPRECATIONS
 }
 
 static gboolean
@@ -437,8 +441,11 @@ update_icon (GvcStreamStatusIcon *icon)
         /* apparently status icon will reset icon even if
          * if doesn't change */
         if (icon->priv->current_icon != n) {
+                G_GNUC_BEGIN_IGNORE_DEPRECATIONS
                 gtk_status_icon_set_from_icon_name (GTK_STATUS_ICON (icon),
                                                     icon->priv->icon_names [n]);
+                G_GNUC_END_IGNORE_DEPRECATIONS
+
                 icon->priv->current_icon = n;
         }
 
@@ -469,7 +476,11 @@ update_icon (GvcStreamStatusIcon *icon)
                                           100 * (float)volume / PA_VOLUME_NORM,
                                           gvc_mixer_stream_get_description (icon->priv->mixer_stream));
         }
+
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         gtk_status_icon_set_tooltip_markup (GTK_STATUS_ICON (icon), markup);
+        G_GNUC_END_IGNORE_DEPRECATIONS
+
         g_free (markup);
 }
 
@@ -645,8 +656,10 @@ gvc_stream_status_icon_constructor (GType                  type,
 
         icon = GVC_STREAM_STATUS_ICON (object);
 
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
         gtk_status_icon_set_from_icon_name (GTK_STATUS_ICON (icon),
                                             icon->priv->icon_names[0]);
+        G_GNUC_END_IGNORE_DEPRECATIONS
 
         /* window */
         icon->priv->dock = gtk_window_new (GTK_WINDOW_POPUP);
diff --git a/gnome-flashback/libworkarounds/Makefile.am b/gnome-flashback/libworkarounds/Makefile.am
new file mode 100644
index 0000000..bc75212
--- /dev/null
+++ b/gnome-flashback/libworkarounds/Makefile.am
@@ -0,0 +1,28 @@
+NULL =
+
+noinst_LTLIBRARIES = \
+	libworkarounds.la \
+	$(NULL)
+
+libworkarounds_la_CFLAGS = \
+	$(IDLE_MONITOR_CFLAGS) \
+	$(WARN_CFLAGS) \
+	$(AM_CFLAGS) \
+	-I$(top_builddir)/gnome-flashback/libworkarounds \
+	$(NULL)
+
+libworkarounds_la_SOURCES = \
+	flashback-workarounds.c \
+	flashback-workarounds.h \
+	$(NULL)
+
+libworkarounds_la_LDFLAGS = \
+	$(WARN_LDFLAGS) \
+	$(AM_LDFLAGS) \
+	$(NULL)
+
+libworkarounds_la_LIBADD = \
+	$(IDLE_MONITOR_LIBS) \
+	$(NULL)
+
+-include $(top_srcdir)/git.mk
diff --git a/gnome-flashback/libworkarounds/flashback-workarounds.c b/gnome-flashback/libworkarounds/flashback-workarounds.c
new file mode 100644
index 0000000..b01ec1c
--- /dev/null
+++ b/gnome-flashback/libworkarounds/flashback-workarounds.c
@@ -0,0 +1,762 @@
+/*
+ * Copyright (C) 2015 Alberts Muktupāvels
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Based on code from Owen Taylor, Copyright(C) 2001, 2007 Red Hat, Inc.
+ *
+ * https://git.gnome.org/browse/gtk+/tree/gdk/x11/xsettings-client.c
+ * https://git.gnome.org/browse/gnome-settings-daemon/tree/plugins/xsettings/xsettings-manager.c
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+#include <X11/Xmd.h>
+
+#include "flashback-workarounds.h"
+
+#define BYTES_LEFT(buffer) ((buffer)->data + (buffer)->len - (buffer)->pos)
+#define RETURN_IF_FAIL_BYTES(buffer, n_bytes) if (BYTES_LEFT (buffer) < (n_bytes)) return FALSE;
+#define XSETTINGS_PAD(n,m) ((n + m - 1) & (~(m-1)))
+
+struct _FlashbackWorkarounds
+{
+  GObject      parent;
+
+  GSettings   *g_settings;
+  GtkSettings *gtk_settings;
+
+  gboolean     fix_app_menu;
+  gchar       *fix_button_layout;
+
+  guint        idle_id;
+  guint        timeout_id;
+
+  Display     *xdisplay;
+
+  Atom         selection_atom;
+  Atom         xsettings_atom;
+
+  Window       manager_window;
+
+  GHashTable  *xsettings;
+  CARD32       serial;
+};
+
+G_DEFINE_TYPE (FlashbackWorkarounds, flashback_workarounds, G_TYPE_OBJECT)
+
+static void add_workarounds (FlashbackWorkarounds *workarounds);
+
+typedef enum
+{
+  XSETTINGS_TYPE_INT    = 0,
+  XSETTINGS_TYPE_STRING = 1,
+  XSETTINGS_TYPE_COLOR  = 2
+} XSettingsType;
+
+typedef struct
+{
+  gchar         *name;
+  XSettingsType  type;
+  GValue        *value;
+  gulong         last_change_serial;
+} XSettingsSetting;
+
+typedef struct
+{
+  gchar   byte_order;
+  gulong  len;
+  guchar *data;
+  guchar *pos;
+} XSettingsBuffer;
+
+static gboolean
+fetch_card16 (XSettingsBuffer *buffer,
+              CARD16          *result)
+{
+  CARD16 x;
+
+  RETURN_IF_FAIL_BYTES (buffer, 2);
+
+  x = *(CARD16 *)buffer->pos;
+  buffer->pos += 2;
+
+  if (buffer->byte_order == MSBFirst)
+    *result = GUINT16_FROM_BE (x);
+  else
+    *result = GUINT16_FROM_LE (x);
+
+  return TRUE;
+}
+
+static gboolean
+fetch_ushort (XSettingsBuffer *buffer,
+              gushort         *result)
+{
+  CARD16 x;
+  gboolean r;
+
+  r = fetch_card16 (buffer, &x);
+  if (r)
+    *result = x;
+
+  return r;
+}
+
+static gboolean
+fetch_card32 (XSettingsBuffer *buffer,
+              CARD32          *result)
+{
+  CARD32 x;
+
+  RETURN_IF_FAIL_BYTES (buffer, 4);
+
+  x = *(CARD32 *)buffer->pos;
+  buffer->pos += 4;
+
+  if (buffer->byte_order == MSBFirst)
+    *result = GUINT32_FROM_BE (x);
+  else
+    *result = GUINT32_FROM_LE (x);
+
+  return TRUE;
+}
+
+static gboolean
+fetch_card8 (XSettingsBuffer *buffer,
+             CARD8           *result)
+{
+  RETURN_IF_FAIL_BYTES (buffer, 1);
+
+  *result = *(CARD8 *)buffer->pos;
+  buffer->pos += 1;
+
+  return TRUE;
+}
+
+static gboolean
+fetch_string (XSettingsBuffer  *buffer,
+              guint             length,
+              gchar           **result)
+{
+  guint pad_len;
+
+  pad_len = XSETTINGS_PAD (length, 4);
+  if (pad_len < length)
+    return FALSE;
+
+  RETURN_IF_FAIL_BYTES (buffer, pad_len);
+
+  *result = g_strndup ((gchar *) buffer->pos, length);
+  buffer->pos += pad_len;
+
+  return TRUE;
+}
+
+static void
+free_gvalue (gpointer user_data)
+{
+  GValue *value;
+
+  value = (GValue *) user_data;
+
+  g_value_unset (value);
+  g_free (value);
+}
+
+static void
+free_xsetting (gpointer data)
+{
+  XSettingsSetting *setting;
+
+  setting = (XSettingsSetting *) data;
+
+  g_free (setting->name);
+  free_gvalue (setting->value);
+  g_free (setting);
+}
+
+static GHashTable *
+parse_settings (FlashbackWorkarounds *workarounds,
+                guchar               *data,
+                gulong                n_items)
+{
+  XSettingsBuffer buffer;
+  GHashTable *settings;
+  CARD32 n_entries;
+  CARD32 i;
+  GValue *value;
+  gchar *x_name;
+  gulong last_change_serial;
+  XSettingsSetting *setting;
+
+  buffer.pos = buffer.data = data;
+  buffer.len = n_items;
+
+  if (!fetch_card8 (&buffer, (guchar *)&buffer.byte_order))
+    return NULL;
+
+  if (buffer.byte_order != MSBFirst && buffer.byte_order != LSBFirst)
+    return NULL;
+
+  buffer.pos += 3;
+
+  if (!fetch_card32 (&buffer, &workarounds->serial) ||
+      !fetch_card32 (&buffer, &n_entries))
+    return NULL;
+
+  settings = NULL;
+  value = NULL;
+  x_name = NULL;
+
+  for (i = 0; i < n_entries; i++)
+    {
+      CARD8 type;
+      CARD16 name_len;
+      CARD32 v_int;
+
+      if (!fetch_card8 (&buffer, &type))
+        goto out;
+
+      buffer.pos += 1;
+
+      if (!fetch_card16 (&buffer, &name_len))
+        goto out;
+
+      if (!fetch_string (&buffer, name_len, &x_name) || !fetch_card32 (&buffer, &v_int))
+        goto out;
+
+      last_change_serial = (gulong) v_int;
+
+      switch (type)
+        {
+          case XSETTINGS_TYPE_INT:
+            if (!fetch_card32 (&buffer, &v_int))
+              goto out;
+
+            value = g_new0 (GValue, 1);
+            g_value_init (value, G_TYPE_INT);
+            g_value_set_int (value, (gint32) v_int);
+            break;
+
+          case XSETTINGS_TYPE_STRING:
+            {
+              gchar *s;
+
+              if (!fetch_card32 (&buffer, &v_int) || !fetch_string (&buffer, v_int, &s))
+                goto out;
+
+              value = g_new0 (GValue, 1);
+              g_value_init (value, G_TYPE_STRING);
+              g_value_take_string (value, s);
+            }
+            break;
+
+          case XSETTINGS_TYPE_COLOR:
+            /* GNOME Settings Daemon does not export settings with color type. */
+            g_free (x_name);
+            x_name = NULL;
+            break;
+
+          default:
+            /* Unknown type */
+            g_free (x_name);
+            x_name = NULL;
+            break;
+        }
+
+      if (settings == NULL)
+        settings = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                          g_free, free_xsetting);
+
+      if (g_hash_table_lookup (settings, x_name) != NULL)
+        goto out;
+
+      if (x_name != NULL)
+        {
+          setting = g_new0 (XSettingsSetting, 1);
+
+          setting->name = g_strdup (x_name);
+          setting->type = type;
+          setting->value = value;
+          setting->last_change_serial = last_change_serial;
+
+          g_hash_table_insert (settings, (gpointer) x_name, setting);
+
+          x_name = NULL;
+          value = NULL;
+        }
+    }
+
+  return settings;
+
+out:
+
+  if (value)
+    free_gvalue (value);
+
+  if (settings)
+    g_hash_table_unref (settings);
+
+  g_free (x_name);
+
+  return NULL;
+}
+
+static gboolean
+read_settings (FlashbackWorkarounds *workarounds)
+{
+  GdkDisplay *display;
+  gint result;
+  Atom type;
+  gint format;
+  gulong n_items;
+  gulong bytes_after;
+  guchar *data;
+
+  display = gdk_x11_lookup_xdisplay (workarounds->xdisplay);
+
+  gdk_x11_display_error_trap_push (display);
+  result = XGetWindowProperty (workarounds->xdisplay, workarounds->manager_window,
+                               workarounds->xsettings_atom, 0, LONG_MAX,
+                               False, workarounds->xsettings_atom,
+                               &type, &format, &n_items, &bytes_after, &data);
+  gdk_x11_display_error_trap_pop_ignored (display);
+
+  if (result == Success && type != None)
+    {
+      if (type == workarounds->xsettings_atom && format == 8)
+        workarounds->xsettings = parse_settings (workarounds, data, n_items);
+
+      XFree (data);
+    }
+
+  if (workarounds->xsettings)
+    return TRUE;
+
+  return FALSE;
+}
+
+static gchar
+get_byte_order (void)
+{
+  CARD32 myint = 0x01020304;
+  return (*(gchar *)&myint == 1) ? MSBFirst : LSBFirst;
+}
+
+static void
+align_string (GString *string,
+              gint     alignment)
+{
+  while ((string->len % alignment) != 0)
+    g_string_append_c (string, '\0');
+}
+
+static void
+setting_store (XSettingsSetting *setting,
+               GString          *buffer)
+{
+  guint16 len16;
+
+  g_string_append_c (buffer, setting->type);
+  g_string_append_c (buffer, 0);
+
+  len16 = strlen (setting->name);
+  g_string_append_len (buffer, (gchar *) &len16, 2);
+  g_string_append (buffer, setting->name);
+  align_string (buffer, 4);
+
+  g_string_append_len (buffer, (gchar *) &setting->last_change_serial, 4);
+
+  if (setting->type == XSETTINGS_TYPE_INT)
+    {
+      gint value;
+
+      value = g_value_get_int (setting->value);
+
+      g_string_append_len (buffer, (gchar *) &value, 4);
+    }
+  else if (setting->type == XSETTINGS_TYPE_STRING)
+    {
+      const gchar *string;
+      guint32 len32;
+
+      string = g_value_get_string (setting->value);
+      len32 = strlen (string);
+      g_string_append_len (buffer, (gchar *) &len32, 4);
+      g_string_append (buffer, string);
+      align_string (buffer, 4);
+    }
+  else if (setting->type == XSETTINGS_TYPE_COLOR)
+    {
+      /* GNOME Settings Daemon does not export settings with color type. */
+    }
+}
+
+static void
+write_settings (FlashbackWorkarounds *workarounds)
+{
+  GString *buffer;
+  GHashTableIter iter;
+  int n_settings;
+  gpointer value;
+
+  n_settings = g_hash_table_size (workarounds->xsettings);
+
+  buffer = g_string_new (NULL);
+  g_string_append_c (buffer, get_byte_order ());
+  g_string_append_c (buffer, '\0');
+  g_string_append_c (buffer, '\0');
+  g_string_append_c (buffer, '\0');
+
+  g_string_append_len (buffer, (gchar *) &workarounds->serial, 4);
+  g_string_append_len (buffer, (gchar *) &n_settings, 4);
+
+  g_hash_table_iter_init (&iter, workarounds->xsettings);
+  while (g_hash_table_iter_next (&iter, NULL, &value))
+    setting_store (value, buffer);
+
+  XChangeProperty (workarounds->xdisplay, workarounds->manager_window,
+                   workarounds->xsettings_atom, workarounds->xsettings_atom,
+                   8, PropModeReplace, (guchar *) buffer->str, buffer->len);
+
+  g_string_free (buffer, TRUE);
+  g_hash_table_unref (workarounds->xsettings);
+  workarounds->xsettings = NULL;
+}
+
+static void
+apply_app_menu_workaround (FlashbackWorkarounds *workarounds)
+{
+  const gchar *key;
+  XSettingsSetting *setting;
+
+  key = "Gtk/ShellShowsAppMenu";
+  setting = g_hash_table_lookup (workarounds->xsettings, key);
+
+  if (setting != NULL)
+    {
+      g_hash_table_steal (workarounds->xsettings, key);
+      free_gvalue (setting->value);
+    }
+  else
+    {
+      setting = g_new0 (XSettingsSetting, 1);
+      setting->name = g_strdup (key);
+      setting->type = XSETTINGS_TYPE_INT;
+      setting->last_change_serial = 0;
+    }
+
+  setting->value = g_new0 (GValue, 1);
+  g_value_init (setting->value, G_TYPE_INT);
+  g_value_set_int (setting->value, 0);
+
+  g_hash_table_insert (workarounds->xsettings, g_strdup (key), setting);
+}
+
+static void
+apply_button_layout_workaround (FlashbackWorkarounds *workarounds)
+{
+  const gchar *key;
+  XSettingsSetting *setting;
+
+  key = "Gtk/DecorationLayout";
+  setting = g_hash_table_lookup (workarounds->xsettings, key);
+
+  if (setting != NULL)
+    {
+      g_hash_table_steal (workarounds->xsettings, key);
+      free_gvalue (setting->value);
+    }
+  else
+    {
+      setting = g_new0 (XSettingsSetting, 1);
+      setting->name = g_strdup (key);
+      setting->type = XSETTINGS_TYPE_STRING;
+      setting->last_change_serial = 0;
+    }
+
+  setting->value = g_new0 (GValue, 1);
+  g_value_init (setting->value, G_TYPE_STRING);
+  g_value_set_string (setting->value, workarounds->fix_button_layout);
+
+  g_hash_table_insert (workarounds->xsettings, g_strdup (key), setting);
+}
+
+static gboolean
+apply_workarounds (FlashbackWorkarounds *workarounds)
+{
+  gboolean gtk_shell_shows_app_menu;
+  gchar *gtk_decoration_layout;
+  gboolean need_workarounds;
+
+  g_object_get (workarounds->gtk_settings,
+                "gtk-shell-shows-app-menu", &gtk_shell_shows_app_menu,
+                NULL);
+
+  g_object_get (workarounds->gtk_settings,
+                "gtk-decoration-layout", &gtk_decoration_layout,
+                NULL);
+
+  need_workarounds = gtk_shell_shows_app_menu;
+  if (g_strcmp0 (gtk_decoration_layout, workarounds->fix_button_layout) != 0)
+    need_workarounds = TRUE;
+
+  g_free (gtk_decoration_layout);
+
+  if (!need_workarounds)
+    return TRUE;
+
+  workarounds->manager_window = XGetSelectionOwner (workarounds->xdisplay,
+                                                    workarounds->selection_atom);
+
+  if (workarounds->manager_window == None)
+    return FALSE;
+
+  if (!read_settings (workarounds))
+    return FALSE;
+
+  if (workarounds->fix_app_menu)
+    apply_app_menu_workaround (workarounds);
+
+  if (g_strcmp0 (workarounds->fix_button_layout, "") != 0)
+    apply_button_layout_workaround (workarounds);
+
+  write_settings (workarounds);
+
+  return TRUE;
+}
+
+static gboolean
+try_again (gpointer user_data)
+{
+  FlashbackWorkarounds *workarounds;
+
+  workarounds = FLASHBACK_WORKAROUNDS (user_data);
+
+  add_workarounds (workarounds);
+
+  workarounds->timeout_id = 0;
+  return G_SOURCE_REMOVE;
+}
+
+static gboolean
+add_workarounds_real (gpointer user_data)
+{
+  FlashbackWorkarounds *workarounds;
+  gboolean fix_app_menu;
+  gchar *fix_button_layout;
+
+  workarounds = FLASHBACK_WORKAROUNDS (user_data);
+
+  fix_app_menu = g_settings_get_boolean (workarounds->g_settings,
+                                         "fix-app-menu");
+  fix_button_layout = g_settings_get_string (workarounds->g_settings,
+                                             "fix-button-layout");
+
+  g_free (workarounds->fix_button_layout);
+
+  workarounds->fix_app_menu = fix_app_menu;
+  workarounds->fix_button_layout = fix_button_layout;
+
+  if (!fix_app_menu && g_strcmp0 (fix_button_layout, "") == 0)
+    {
+      workarounds->idle_id = 0;
+      return G_SOURCE_REMOVE;
+    }
+
+  if (!apply_workarounds (workarounds))
+    {
+      if (workarounds->timeout_id > 0)
+        g_source_remove (workarounds->timeout_id);
+
+      workarounds->timeout_id = g_timeout_add (100, try_again, workarounds);
+      g_source_set_name_by_id (workarounds->timeout_id,
+                               "[gnome-flashback] try_again");
+    }
+
+  workarounds->idle_id = 0;
+  return G_SOURCE_REMOVE;
+}
+
+static void
+add_workarounds (FlashbackWorkarounds *workarounds)
+{
+  if (workarounds->idle_id > 0)
+    g_source_remove (workarounds->idle_id);
+
+  workarounds->idle_id = g_idle_add (add_workarounds_real, workarounds);
+  g_source_set_name_by_id (workarounds->idle_id,
+                           "[gnome-flashback] add_workarounds_real");
+}
+
+static void
+remove_workarounds (void)
+{
+  GSettings *settings;
+  GVariant *overrides;
+
+  settings = g_settings_new ("org.gnome.settings-daemon.plugins.xsettings");
+
+  overrides = g_settings_get_value (settings, "overrides");
+  g_settings_set_value (settings, "overrides", overrides);
+
+  g_variant_unref (overrides);
+  g_object_unref (settings);
+}
+
+static void
+g_settings_changed (GSettings   *settings,
+                    const gchar *key,
+                    gpointer     user_data)
+{
+  FlashbackWorkarounds *workarounds;
+  gboolean fix_app_menu;
+  gchar *fix_button_layout;
+  gboolean reset;
+
+  workarounds = FLASHBACK_WORKAROUNDS (user_data);
+
+  fix_app_menu = g_settings_get_boolean (workarounds->g_settings,
+                                         "fix-app-menu");
+  fix_button_layout = g_settings_get_string (workarounds->g_settings,
+                                             "fix-button-layout");
+
+  reset = FALSE;
+
+  if (workarounds->fix_app_menu && !fix_app_menu)
+    reset = TRUE;
+
+  if (g_strcmp0 (workarounds->fix_button_layout, "") != 0 &&
+      g_strcmp0 (fix_button_layout, "") == 0)
+    reset = TRUE;
+
+  g_free (fix_button_layout);
+
+  if (reset)
+    {
+      remove_workarounds ();
+      return;
+    }
+
+  add_workarounds (workarounds);
+}
+
+static void
+gtk_settings_changed (GtkSettings *settings,
+                      GParamSpec  *pspec,
+                      gpointer     user_data)
+{
+  FlashbackWorkarounds *workarounds;
+
+  workarounds = FLASHBACK_WORKAROUNDS (user_data);
+
+  add_workarounds (workarounds);
+}
+
+static void
+x11_init (FlashbackWorkarounds *workarounds)
+{
+  GdkDisplay *display;
+  Display *xdisplay;
+  GdkScreen *screen;
+  gint number;
+  gchar *atom;
+
+  display = gdk_display_get_default ();
+  xdisplay = gdk_x11_display_get_xdisplay (display);
+  screen = gdk_display_get_default_screen (display);
+  number = gdk_screen_get_number (screen);
+  atom = g_strdup_printf ("_XSETTINGS_S%d", number);
+
+  workarounds->xdisplay = xdisplay;
+  workarounds->selection_atom = XInternAtom (xdisplay, atom, False);
+  workarounds->xsettings_atom = XInternAtom (xdisplay, "_XSETTINGS_SETTINGS", False);
+
+  g_free (atom);
+}
+
+static void
+flashback_workarounds_dispose (GObject *object)
+{
+  FlashbackWorkarounds *workarounds;
+
+  workarounds = FLASHBACK_WORKAROUNDS (object);
+
+  g_clear_object (&workarounds->g_settings);
+  g_signal_handlers_disconnect_by_func (workarounds->gtk_settings,
+                                        gtk_settings_changed,
+                                        workarounds);
+
+  g_free (workarounds->fix_button_layout);
+
+  if (workarounds->idle_id > 0)
+    {
+      g_source_remove (workarounds->idle_id);
+      workarounds->idle_id = 0;
+    }
+
+  if (workarounds->timeout_id > 0)
+    {
+      g_source_remove (workarounds->timeout_id);
+      workarounds->timeout_id = 0;
+    }
+
+  if (workarounds->xsettings)
+    {
+      g_hash_table_unref (workarounds->xsettings);
+      workarounds->xsettings = NULL;
+    }
+
+  remove_workarounds ();
+
+  G_OBJECT_CLASS (flashback_workarounds_parent_class)->dispose (object);
+}
+
+static void
+flashback_workarounds_class_init (FlashbackWorkaroundsClass *workarounds_class)
+{
+  GObjectClass *object_class;
+
+  object_class = G_OBJECT_CLASS (workarounds_class);
+
+  object_class->dispose = flashback_workarounds_dispose;
+}
+
+static void
+flashback_workarounds_init (FlashbackWorkarounds *workarounds)
+{
+  x11_init (workarounds);
+
+  workarounds->g_settings = g_settings_new ("org.gnome.gnome-flashback.workarounds");
+  workarounds->gtk_settings = gtk_settings_get_default ();
+
+  g_signal_connect (workarounds->g_settings, "changed",
+                    G_CALLBACK (g_settings_changed), workarounds);
+  g_signal_connect (workarounds->gtk_settings, "notify::gtk-shell-shows-app-menu",
+                    G_CALLBACK (gtk_settings_changed), workarounds);
+  g_signal_connect (workarounds->gtk_settings, "notify::gtk-decoration-layout",
+                    G_CALLBACK (gtk_settings_changed), workarounds);
+
+  add_workarounds (workarounds);
+}
+
+FlashbackWorkarounds *
+flashback_workarounds_new (void)
+{
+	return g_object_new (FLASHBACK_TYPE_WORKAROUNDS, NULL);
+}
diff --git a/gnome-flashback/libworkarounds/flashback-workarounds.h b/gnome-flashback/libworkarounds/flashback-workarounds.h
new file mode 100644
index 0000000..fba2969
--- /dev/null
+++ b/gnome-flashback/libworkarounds/flashback-workarounds.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Alberts Muktupāvels
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FLASHBACK_WORKAROUNDS_H
+#define FLASHBACK_WORKAROUNDS_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define FLASHBACK_TYPE_WORKAROUNDS flashback_workarounds_get_type ()
+G_DECLARE_FINAL_TYPE (FlashbackWorkarounds, flashback_workarounds,
+                      FLASHBACK, WORKAROUNDS, GObject)
+
+FlashbackWorkarounds *flashback_workarounds_new (void);
+
+G_END_DECLS
+
+#endif
diff --git a/modulesets/gnome-flashback-3.14.modules b/modulesets/gnome-flashback-3.14.modules
new file mode 100644
index 0000000..e126f64
--- /dev/null
+++ b/modulesets/gnome-flashback-3.14.modules
@@ -0,0 +1,158 @@
+<?xml version="1.0"?>
+<!DOCTYPE moduleset SYSTEM "moduleset.dtd">
+<?xml-stylesheet type="text/xsl" href="moduleset.xsl"?>
+<moduleset>
+  <repository type="git" name="git.gnome.org" default="yes" href="git://git.gnome.org/" />
+  <repository type="tarball" name="launchpad-tar" href="https://launchpad.net/" />
+
+  <include href="https://git.gnome.org/browse/gnome-modulesets/plain/gnome-world.modules?h=gnome-3-14" />
+
+  <cmake id="compiz" force-non-srcdir-builds="yes"
+         cmakeargs="-DUSE_GCONF=OFF -DUSE_GSETTINGS=ON -DCOMPIZ_DEFAULT_PLUGINS=core,composite,opengl,decor,resize,place,move">
+    <branch repo="launchpad-tar" module="compiz/0.9.12/${version}/+download/compiz-${version}.tar.bz2"
+            version="0.9.12.1" hash="sha256:8b9d6a72c581c96b820dff182669864aeb8fd1989e95ff56a73203fc478d854e"
+            size="4569138">
+      <patch file="compiz-auto-add-ccp.patch" strip="1" />
+    </branch>
+    <dependencies>
+      <dep package="boost" />
+      <dep package="cairo" />
+      <dep package="dbus-glib" />
+      <dep package="glib" />
+      <dep package="glibmm" />
+      <dep package="gtk+" />
+      <dep package="gnome-control-center" />
+      <dep package="gsettings-desktop-schemas" />
+      <dep package="intltool" />
+      <dep package="libnotify" />
+      <dep package="libjpeg" />
+      <dep package="libpng" />
+      <dep package="librsvg" />
+      <dep package="libwnck" />
+      <dep package="libxml2" />
+      <dep package="libX11" />
+      <dep package="libXcomposite" />
+      <dep package="libXcursor" />
+      <dep package="libXdamage" />
+      <dep package="libXext" />
+      <dep package="libXfixes" />
+      <dep package="libXi" />
+      <dep package="libXinerama" />
+      <dep package="libXrandr" />
+      <dep package="metacity" />
+      <dep package="pango" />
+      <dep package="pkg-config" />
+      <dep package="protobuf" />
+      <dep package="sm" />
+      <dep package="startup-notification" />
+    </dependencies>
+  </cmake>
+
+  <autotools id="gnome-applets" autogenargs="--enable-mini-commander">
+    <branch revision="gnome-3-14" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-panel" />
+      <dep package="libgtop" />
+      <dep package="libgnomekbd" />
+      <dep package="gucharmap" />
+      <dep package="libgweather" />
+      <dep package="gdk-pixbuf" />
+      <dep package="gtk+" />
+      <dep package="glib" />
+      <dep package="libxklavier" />
+      <dep package="libwnck" />
+      <dep package="libnotify" />
+      <dep package="dbus" />
+      <dep package="dbus-glib" />
+      <dep package="pygobject" />
+      <dep package="adwaita-icon-theme" />
+      <dep package="libxml2" />
+      <dep package="polkit-gobject" />
+    </dependencies>
+    <after>
+      <dep package="gnome-control-center" />
+    </after>
+  </autotools>
+
+  <autotools id="gnome-flashback">
+    <branch revision="gnome-3-14" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-desktop" />
+      <dep package="gtk+" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="gnome-panel">
+    <branch revision="gnome-3-14" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-desktop" />
+      <dep package="libwnck" />
+      <dep package="evolution-data-server" />
+      <dep package="gnome-menus" />
+      <dep package="dbus-glib" />
+      <dep package="librsvg" />
+      <dep package="libgweather" />
+      <dep package="libcanberra" />
+      <dep package="yelp-tools" />
+    </dependencies>
+    <suggests>
+      <dep package="polkit-gobject" />
+    </suggests>
+  </autotools>
+
+  <autotools id="metacity">
+    <branch revision="gnome-3-14" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gdk-pixbuf" />
+      <dep package="gtk+" />
+      <dep package="gsettings-desktop-schemas" />
+      <dep package="intltool" />
+      <dep package="libcanberra" />
+      <dep package="zenity" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="notification-daemon">
+    <branch revision="gnome-3-14" />
+    <dependencies>
+      <dep package="dbus" />
+      <dep package="glib" />
+      <dep package="gtk+" />
+      <dep package="libcanberra" />
+    </dependencies>
+  </autotools>
+
+  <metamodule id="meta-gnome-flashback-common">
+    <dependencies>
+      <dep package="gnome-applets" />
+      <dep package="gnome-flashback" />
+      <dep package="gnome-panel" />
+      <dep package="notification-daemon" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback-compiz">
+    <dependencies>
+      <dep package="meta-gnome-flashback-common" />
+      <dep package="compiz" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback-metacity">
+    <dependencies>
+      <dep package="meta-gnome-flashback-common" />
+      <dep package="metacity" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback">
+    <dependencies>
+      <dep package="meta-gnome-flashback-compiz" />
+      <dep package="meta-gnome-flashback-metacity" />
+    </dependencies>
+  </metamodule>
+</moduleset>
diff --git a/modulesets/gnome-flashback-3.16.modules b/modulesets/gnome-flashback-3.16.modules
new file mode 100644
index 0000000..4f4e546
--- /dev/null
+++ b/modulesets/gnome-flashback-3.16.modules
@@ -0,0 +1,154 @@
+<?xml version="1.0"?>
+<!DOCTYPE moduleset SYSTEM "moduleset.dtd">
+<?xml-stylesheet type="text/xsl" href="moduleset.xsl"?>
+<moduleset>
+  <repository type="git" name="git.gnome.org" default="yes" href="git://git.gnome.org/" />
+  <repository type="bzr" name="launchpad.net" href="lp:" branches-template="%(module)s" />
+
+  <include href="https://git.gnome.org/browse/gnome-modulesets/plain/gnome-world.modules?h=gnome-3-16" />
+
+  <cmake id="compiz" force-non-srcdir-builds="yes"
+         cmakeargs="-DUSE_GCONF=OFF -DUSE_GSETTINGS=ON -DCOMPIZ_DEFAULT_PLUGINS=core,composite,opengl,decor,resize,place,move">
+    <branch repo="launchpad.net" module="compiz" />
+    <dependencies>
+      <dep package="boost" />
+      <dep package="cairo" />
+      <dep package="dbus-glib" />
+      <dep package="glib" />
+      <dep package="glibmm" />
+      <dep package="gtk+" />
+      <dep package="gnome-control-center" />
+      <dep package="gsettings-desktop-schemas" />
+      <dep package="intltool" />
+      <dep package="libnotify" />
+      <dep package="libjpeg" />
+      <dep package="libpng" />
+      <dep package="librsvg" />
+      <dep package="libwnck" />
+      <dep package="libxml2" />
+      <dep package="libX11" />
+      <dep package="libXcomposite" />
+      <dep package="libXcursor" />
+      <dep package="libXdamage" />
+      <dep package="libXext" />
+      <dep package="libXfixes" />
+      <dep package="libXi" />
+      <dep package="libXinerama" />
+      <dep package="libXrandr" />
+      <dep package="metacity" />
+      <dep package="pango" />
+      <dep package="pkg-config" />
+      <dep package="protobuf" />
+      <dep package="sm" />
+      <dep package="startup-notification" />
+    </dependencies>
+  </cmake>
+
+  <autotools id="gnome-applets" autogenargs="--enable-mini-commander">
+    <branch revision="gnome-3-16" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-panel" />
+      <dep package="libgtop" />
+      <dep package="libgnomekbd" />
+      <dep package="gucharmap" />
+      <dep package="libgweather" />
+      <dep package="gdk-pixbuf" />
+      <dep package="gtk+" />
+      <dep package="glib" />
+      <dep package="libxklavier" />
+      <dep package="libwnck" />
+      <dep package="libnotify" />
+      <dep package="dbus" />
+      <dep package="dbus-glib" />
+      <dep package="pygobject" />
+      <dep package="adwaita-icon-theme" />
+      <dep package="libxml2" />
+      <dep package="polkit-gobject" />
+    </dependencies>
+    <after>
+      <dep package="gnome-control-center" />
+    </after>
+  </autotools>
+
+  <autotools id="gnome-flashback">
+    <branch revision="gnome-3-16" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-desktop" />
+      <dep package="gtk+" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="gnome-panel">
+    <branch revision="gnome-3-16" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-desktop" />
+      <dep package="libwnck" />
+      <dep package="evolution-data-server" />
+      <dep package="gnome-menus" />
+      <dep package="dbus-glib" />
+      <dep package="librsvg" />
+      <dep package="libgweather" />
+      <dep package="libcanberra" />
+      <dep package="yelp-tools" />
+    </dependencies>
+    <suggests>
+      <dep package="polkit-gobject" />
+    </suggests>
+  </autotools>
+
+  <autotools id="metacity">
+    <branch revision="gnome-3-16" />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gdk-pixbuf" />
+      <dep package="gtk+" />
+      <dep package="gsettings-desktop-schemas" />
+      <dep package="intltool" />
+      <dep package="libcanberra" />
+      <dep package="zenity" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="notification-daemon">
+    <branch revision="gnome-3-16" />
+    <dependencies>
+      <dep package="dbus" />
+      <dep package="glib" />
+      <dep package="gtk+" />
+      <dep package="libcanberra" />
+    </dependencies>
+  </autotools>
+
+  <metamodule id="meta-gnome-flashback-common">
+    <dependencies>
+      <dep package="gnome-applets" />
+      <dep package="gnome-flashback" />
+      <dep package="gnome-panel" />
+      <dep package="notification-daemon" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback-compiz">
+    <dependencies>
+      <dep package="meta-gnome-flashback-common" />
+      <dep package="compiz" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback-metacity">
+    <dependencies>
+      <dep package="meta-gnome-flashback-common" />
+      <dep package="metacity" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback">
+    <dependencies>
+      <dep package="meta-gnome-flashback-compiz" />
+      <dep package="meta-gnome-flashback-metacity" />
+    </dependencies>
+  </metamodule>
+</moduleset>
diff --git a/modulesets/gnome-flashback-3.18.modules b/modulesets/gnome-flashback-3.18.modules
new file mode 100644
index 0000000..c7b6de8
--- /dev/null
+++ b/modulesets/gnome-flashback-3.18.modules
@@ -0,0 +1,169 @@
+<?xml version="1.0"?>
+<!DOCTYPE moduleset SYSTEM "moduleset.dtd">
+<?xml-stylesheet type="text/xsl" href="moduleset.xsl"?>
+<moduleset>
+  <repository type="git" name="git.gnome.org" default="yes" href="git://git.gnome.org/" />
+  <repository type="bzr" name="launchpad.net" href="lp:" branches-template="%(module)s" />
+  <repository type="git" name="github.com" href="git://github.com/" />
+
+  <include href="https://git.gnome.org/browse/jhbuild/plain/modulesets/gnome-world.modules" />
+
+  <cmake id="compiz" force-non-srcdir-builds="yes"
+         cmakeargs="-DUSE_GCONF=OFF -DUSE_GSETTINGS=ON -DCOMPIZ_DEFAULT_PLUGINS=core,composite,opengl,decor,resize,place,move">
+    <branch repo="launchpad.net" module="compiz" />
+    <dependencies>
+      <dep package="boost" />
+      <dep package="cairo" />
+      <dep package="dbus-glib" />
+      <dep package="glib" />
+      <dep package="glibmm" />
+      <dep package="gtk+" />
+      <dep package="gnome-control-center" />
+      <dep package="gsettings-desktop-schemas" />
+      <dep package="intltool" />
+      <dep package="libnotify" />
+      <dep package="libjpeg" />
+      <dep package="libpng" />
+      <dep package="librsvg" />
+      <dep package="libwnck" />
+      <dep package="libxml2" />
+      <dep package="libX11" />
+      <dep package="libXcomposite" />
+      <dep package="libXcursor" />
+      <dep package="libXdamage" />
+      <dep package="libXext" />
+      <dep package="libXfixes" />
+      <dep package="libXi" />
+      <dep package="libXinerama" />
+      <dep package="libXrandr" />
+      <dep package="metacity" />
+      <dep package="pango" />
+      <dep package="pkg-config" />
+      <dep package="protobuf" />
+      <dep package="sm" />
+      <dep package="startup-notification" />
+    </dependencies>
+  </cmake>
+
+  <autotools id="gnome-applets" autogenargs="--enable-mini-commander">
+    <branch />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-panel" />
+      <dep package="libgtop" />
+      <dep package="libgnomekbd" />
+      <dep package="gucharmap" />
+      <dep package="libgweather" />
+      <dep package="gdk-pixbuf" />
+      <dep package="gtk+" />
+      <dep package="glib" />
+      <dep package="libxklavier" />
+      <dep package="libwnck" />
+      <dep package="libnotify" />
+      <dep package="m4-common" />
+      <dep package="dbus" />
+      <dep package="dbus-glib" />
+      <dep package="pygobject" />
+      <dep package="adwaita-icon-theme" />
+      <dep package="libxml2" />
+      <dep package="polkit-gobject" />
+    </dependencies>
+    <after>
+      <dep package="gnome-control-center" />
+    </after>
+  </autotools>
+
+  <autotools id="gnome-flashback">
+    <branch />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-desktop" />
+      <dep package="gtk+" />
+      <dep package="m4-common" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="gnome-panel">
+    <branch />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gnome-desktop" />
+      <dep package="libwnck" />
+      <dep package="evolution-data-server" />
+      <dep package="gnome-menus" />
+      <dep package="dbus-glib" />
+      <dep package="librsvg" />
+      <dep package="libgweather" />
+      <dep package="libcanberra" />
+      <dep package="m4-common" />
+      <dep package="yelp-tools" />
+    </dependencies>
+    <suggests>
+      <dep package="polkit-gobject" />
+    </suggests>
+  </autotools>
+
+  <autotools id="libstatus-notifier">
+    <branch repo="github.com" module="albertsmuktupavels/libstatus-notifier" />
+    <dependencies>
+      <dep package="glib" />
+      <dep package="gtk-doc" />
+      <dep package="m4-common" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="metacity">
+    <branch />
+    <dependencies>
+      <dep package="intltool" />
+      <dep package="gdk-pixbuf" />
+      <dep package="gtk+" />
+      <dep package="gsettings-desktop-schemas" />
+      <dep package="intltool" />
+      <dep package="libcanberra" />
+      <dep package="m4-common" />
+      <dep package="zenity" />
+    </dependencies>
+  </autotools>
+
+  <autotools id="notification-daemon">
+    <branch />
+    <dependencies>
+      <dep package="dbus" />
+      <dep package="glib" />
+      <dep package="gtk+" />
+      <dep package="libcanberra" />
+      <dep package="m4-common" />
+    </dependencies>
+  </autotools>
+
+  <metamodule id="meta-gnome-flashback-common">
+    <dependencies>
+      <dep package="gnome-applets" />
+      <dep package="gnome-flashback" />
+      <dep package="gnome-panel" />
+      <dep package="notification-daemon" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback-compiz">
+    <dependencies>
+      <dep package="meta-gnome-flashback-common" />
+      <dep package="compiz" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback-metacity">
+    <dependencies>
+      <dep package="meta-gnome-flashback-common" />
+      <dep package="metacity" />
+    </dependencies>
+  </metamodule>
+
+  <metamodule id="meta-gnome-flashback">
+    <dependencies>
+      <dep package="meta-gnome-flashback-compiz" />
+      <dep package="meta-gnome-flashback-metacity" />
+    </dependencies>
+  </metamodule>
+</moduleset>
diff --git a/modulesets/patches/compiz-auto-add-ccp.patch b/modulesets/patches/compiz-auto-add-ccp.patch
new file mode 100644
index 0000000..d5b7522
--- /dev/null
+++ b/modulesets/patches/compiz-auto-add-ccp.patch
@@ -0,0 +1,58 @@
+=== modified file 'src/main.cpp'
+--- compiz-0.9.12.1.orig/src/main.cpp	2013-02-21 17:05:46 +0000
++++ compiz-0.9.12.1/src/main.cpp	2015-04-23 20:18:28 +0000
+@@ -38,6 +38,11 @@
+ #include "privatescreen.h"
+ #include "privatestackdebugger.h"
+ 
++namespace
++{
++    bool autoAddCCP = true;
++}
++
+ void
+ CompManager::usage ()
+ {
+@@ -48,6 +53,7 @@
+             "  --sm-disable          Disable session management\n"
+             "  --sm-client-id ID     Session management client ID\n"
+             "  --keep-desktop-hints  Retain existing desktop hints\n"
++            "  --no-auto-add-ccp     Do not automatically load the ccp plugin\n"
+             "  --sync                Make all X calls synchronous\n"
+             "  --debug               Enable debug mode\n"
+             "  --version             Show the program version\n"
+@@ -99,6 +105,11 @@
+ 	{
+ 	    useDesktopHints = true;
+ 	}
++	else if (!strcmp (argv[i], "--no-auto-add-ccp"))
++	{
++	    compLogMessage ("core", CompLogLevelInfo, "running without the ccp plugin, no settings will be loaded");
++	    autoAddCCP = false;
++	}
+ 	else if (!strcmp (argv[i], "--replace"))
+ 	{
+ 	    replaceCurrentWm = true;
+@@ -151,6 +162,9 @@
+ 
+     modHandler = new ModifierHandler ();
+ 
++    if (initialPlugins.empty () && autoAddCCP)
++        initialPlugins.push_back ("ccp");
++
+     if (!screen->init (displayName))
+ 	return false;
+ 
+
+=== modified file 'tests/xorg-gtest/src/compiz-xorg-gtest.cpp'
+--- compiz-0.9.12.1.orig/tests/xorg-gtest/src/compiz-xorg-gtest.cpp	2013-07-18 13:06:24 +0000
++++ compiz-0.9.12.1/tests/xorg-gtest/src/compiz-xorg-gtest.cpp	2015-04-23 20:18:28 +0000
+@@ -778,6 +778,7 @@
+     if (flags & ct::CompizProcess::ReplaceCurrentWM)
+ 	args.push_back ("--replace");
+ 
++    args.push_back ("--no-auto-add-ccp");
+     args.push_back ("--send-startup-message");
+ 
+     /* Copy in plugin list and set environment variables */
+
